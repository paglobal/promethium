{"mappings":";;;;;;;;;;;;;;;;;;;;;;;AEAA;ACAA;ACIA,MAAM,mCAAa,GAAsB,EAAE,AAAC;AAC5C,MAAM,mCAAa,GAAsB,EAAE,AAAC;AAC5C,IAAI,yBAAG,GAAG,IAAI,AAAC;AAEA,kDACb,uBAAwC,EACxC;IACA,MAAM,YAAY,GAAG,yBAAG,GAAG,mCAAa,GAAG,mCAAa,AAAC;IACzD,MAAM,MAAM,GAAG,yBAAG,GAAG,KAAK,GAAG,IAAI,AAAC;IAElC,YAAY,CAAC,IAAI,CAAC,uBAAuB,CAAC,CAAC;IAE3C,IAAI,YAAY,CAAC,MAAM,KAAK,CAAC,EAC3B,cAAc,CAAC,IAAM;QACnB,yBAAG,GAAG,MAAM,CAAC;QACb,YAAY,CAAC,OAAO,CAClB,CAAC,uBAAuB,GAAM,uBAAuB,CAAC,OAAO,GAAG,IAAI,AAAC,CACtE,CAAC;QACF,YAAY,CAAC,MAAM,GAAG,CAAC,CAAC;KACzB,CAAC,CAAC;CAEN;;;AMtBM,MAAM,yCAAc,GAA2B,EAAE,AAAC;;ADHzD;AEIe,kDAAwB,MAA4B,EAAE;IACnE,IAAI,WAAW,GAAG,MAAM,CAAC,WAAW,AAAC;IAErC,MAAM,CAAC,sBAAsB,EAAE,OAAO,CAAC,CAAC,IAAI,GAAK;QAC/C,WAAW,GAAG,WAAW,EAAE,GAAG,CAAC,IAAI,CAAC,AAAe,CAAC;KACrD,CAAC,CAAC;IAEH,OAAO,WAAW,CAAC;CACpB;;;ACVc,kDACb,MAA4B,EAC5B;IACA,MAAM,CAAC,0BAA0B,CAAC,OAAO,CAAC,CAAC,yBAAyB,GAAK;QACvE,yBAAyB,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;KAC1C,CAAC,CAAC;IACH,MAAM,CAAC,0BAA0B,CAAC,KAAK,EAAE,CAAC;CAC3C;;;AHJM,SAAS,yCAAa,CAC3B,MAA4B,EAC5B,EAAqD,EACrD;IACA,sGAAsG;IACtG,MAAM,CAAC,UAAU,GAAG,CAAC,CAAC;IAEtB,iDAAiD;IACjD,MAAM,UAAU,GAAG,CAAA,GAAA,wCAAc,CAAA,CAAC,MAAM,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC,AAEpC,AAAC;IACd,UAAU,EAAE,OAAO,CAAC,CAAC,OAAO,GAAK;QAC/B,OAAO,EAAE,CAAC;KACX,CAAC,CAAC;IACH,UAAU,EAAE,KAAK,EAAE,CAAC;IAEpB,gEAAgE;IAChE,CAAA,GAAA,yCAAc,CAAA,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IAE5B,EAAE,CAAC,UAAU,CAAC,CAAC;IAEf,yDAAyD;IACzD,UAAU,EAAE,GAAG,CAAC,IAAM,CAAA,GAAA,wCAA8B,CAAA,CAAC,MAAM,CAAC,CAAC,CAAC;IAE9D,mEAAmE;IACnE,CAAA,GAAA,yCAAc,CAAA,CAAC,GAAG,EAAE,CAAC;CACtB;;AD/BD;AKAA;AAGA,SAAS,yCAAmB,CAAC,WAA+B,EAAE;IAC5D,IAAI,aAAa,GAAG,CAAC,AAAC;IACtB,MAAO,WAAW,EAAE,GAAG,CAAC,aAAa,CAAC,CAAE;QACtC,IAAI,aAAa,KAAK,CAAC,EAAE;YACvB,MAAM,UAAU,GAAG,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,AAAmB,AAAC;YACzD,UAAU,CAAC,OAAO,CAAC,CAAC,OAAO,GAAK;gBAC9B,OAAO,EAAE,CAAC;aACX,CAAC,CAAC;YACH,UAAU,CAAC,KAAK,EAAE,CAAC;SACpB,MAAM;YACL,MAAM,eAAe,GAAG,WAAW,CAAC,GAAG,CAAC,aAAa,CAAC,AAAe,AAAC;YACtE,yCAAmB,CAAC,eAAe,CAAC,CAAC;SACtC;QAED,aAAa,EAAE,CAAC;KACjB;CACF;AAEc,kDACb,MAA4B,EAC5B;IACA,MAAM,WAAW,GAAG,CAAA,GAAA,wCAAc,CAAA,CAAC,MAAM,CAAC,AAAC;IAC3C,yCAAmB,CAAC,WAAW,CAAC,CAAC;CAClC;;;ALtBc,kDAGb,MAAkC,EAAE,EAAkB,EAAE;IACxD,CAAA,GAAA,yCAAa,CAAA,CAAC,MAAM,EAAE,CAAC,UAAU,GAAK,gCAAU,CAAC,MAAM,EAAE,EAAE,EAAE,UAAU,CAAC,CAAC,CAAC;IAE1E,wDAAwD;IACxD,OAAO,IAAM,CAAA,GAAA,wCAA0B,CAAA,CAAC,MAAM,CAAC,CAAC;CACjD;AAED,SAAS,gCAAU,CACjB,MAAkC,EAClC,EAAkB,EAClB,UAAuC,EACvC;IACA,wCAAwC;IACxC,MAAM,aAAa,GAAG,EAAE,CAAC,MAAM,CAAC,WAAW,CAAC,AAAC;IAC7C,gEAAgE;IAChE,MAAM,kBAAkB,GAAG,IAAM;QAC/B,IAAI,OAAO,aAAa,KAAK,UAAU,EACrC,2DAA2D;QAC3D,MAAM,CAAC,WAAW,GAAG,aAAa,EAAE,AAAiB,CAAC;KAEzD,AAAC;IAEF,UAAU,EAAE,GAAG,CAAC,kBAAkB,CAAC,CAAC;CACrC;;AD9BD;AOAA;;AASO,SAAS,yCAAwB,CACtC,MAAkC,EAClC,EAAkB,EAClB,QAAqB,EACrB,OAAsB,GAAG,EAAE,EAC3B;IACA,CAAA,GAAA,yCAAa,CAAA,CAAC,MAAM,EAAE,CAAC,UAAU,GAC/B,gCAAU,CAAC,MAAM,EAAE,EAAE,EAAE,QAAQ,EAAE,OAAO,EAAE,UAAU,CAAC,CACtD,CAAC;IAEF,OAAO,IAAM,CAAA,GAAA,wCAA0B,CAAA,CAAC,MAAM,CAAC,CAAC;CACjD;AAED,SAAS,gCAAU,CACjB,MAAkC,EAClC,EAAkB,EAClB,QAAqB,EACrB,OAAsB,GAAG,EAAE,EAC3B,UAAuC,EACvC;IACA,mEAAmE;IACnE,IAAI,MAAM,CAAC,QAAQ,IAAI,OAAO,CAAC,KAAK,EAClC,MAAM,CAAC,QAAQ,GAAG,KAAK,CAAC;SACnB;QACL,gHAAgH;QAChH,MAAM,aAAa,GAAG,EAAE,CAAC,MAAM,CAAC,WAAW,EAAE,MAAM,CAAC,SAAS,CAAC,AAAC;QAC/D,gEAAgE;QAChE,MAAM,kBAAkB,GAAG,IAAM;YAC/B,IAAI,OAAO,aAAa,KAAK,UAAU,EACrC,2DAA2D;YAC3D,MAAM,CAAC,WAAW,GAAG,aAAa,EAAE,AAAiB,CAAC;SAEzD,AAAC;QAEF,wCAAwC;QACxC,UAAU,EAAE,GAAG,CAAC,kBAAkB,CAAC,CAAC;KACrC;IAED,gFAAgF;IAChF,MAAM,CAAC,QAAQ,GAAG,UAAU,CAAC;IAC7B,MAAM,CAAC,SAAS,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC,KAAK,GAAK,KAAK,EAAE,CAAC,AAAK,CAAC;IACzD,6EAA6E;IAC7E,4DAA4D;IAC5D,MAAM,CAAC,QAAQ,GAAG,UAAU,CAAC;CAC9B;;;ACrDD;;ACAA;AAKe,kDACb,MAA4B,EAC5B,QAAqB,EACrB;IACA,CAAA,GAAA,yCAAa,CAAA,CAAC,MAAM,EAAE,IAAM,gCAAU,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC,CAAC;IAE1D,OAAO,MAAM,CAAC,SAAS,CAAC;CACzB;AAED,SAAS,gCAAU,CAAI,MAA4B,EAAE,QAAqB,EAAE;IAC1E,MAAM,CAAC,QAAQ,GAAG,UAAU,CAAC;IAC7B,MAAM,CAAC,SAAS,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC,KAAK,GAAK,KAAK,EAAE,CAAC,CAAC;IACpD,MAAM,CAAC,QAAQ,GAAG,UAAU,CAAC;CAC9B;;;ADRM,SAAS,yCAAoB,CAClC,MAAkC,EAClC,EAAkB,EAClB,QAAqB,EACrB,OAAsB,GAAG,EAAE,EAC3B;IACA,CAAA,GAAA,yCAAa,CAAA,CAAC,MAAM,EAAE,CAAC,UAAU,GAC/B,wCAAU,CAAC,MAAM,EAAE,EAAE,EAAE,QAAQ,EAAE,OAAO,EAAE,UAAU,CAAC,CACtD,CAAC;IAEF,OAAO;QACL,IAAM,CAAA,GAAA,wCAA0B,CAAA,CAAC,MAAM,CAAC;QACxC,IAAM,CAAA,GAAA,wCAAwB,CAAA,CAAC,MAAM,EAAE,QAAQ,CAAC;QAChD,MAAM,CAAC,SAAS;KACjB,CAAU;CACZ;AAEc,kDACb,MAAkC,EAClC,EAAkB,EAClB,QAAqB,EACrB,OAAsB,GAAG,EAAE,EAC3B,UAAuC,EACvC;IACA,gFAAgF;IAChF,MAAM,CAAC,QAAQ,GAAG,UAAU,CAAC;IAC7B,MAAM,CAAC,SAAS,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC,KAAK,GAAK,KAAK,EAAE,CAAC,AAAK,CAAC;IACzD,6EAA6E;IAC7E,4DAA4D;IAC5D,MAAM,CAAC,QAAQ,GAAG,UAAU,CAAC;IAE7B,mEAAmE;IACnE,IAAI,MAAM,CAAC,QAAQ,IAAI,OAAO,CAAC,KAAK,EAClC,MAAM,CAAC,QAAQ,GAAG,KAAK,CAAC;SACnB;QACL,gHAAgH;QAChH,MAAM,aAAa,GAAG,EAAE,CAAC,MAAM,CAAC,WAAW,EAAE,MAAM,CAAC,SAAS,CAAC,AAAC;QAC/D,gEAAgE;QAChE,MAAM,kBAAkB,GAAG,IAAM;YAC/B,IAAI,OAAO,aAAa,KAAK,UAAU,EACrC,2DAA2D;YAC3D,MAAM,CAAC,WAAW,GAAG,aAAa,EAAE,AAAiB,CAAC;SAEzD,AAAC;QAEF,wCAAwC;QACxC,UAAU,EAAE,GAAG,CAAC,kBAAkB,CAAC,CAAC;KACrC;CACF;;;ARtDD,MAAM,gCAAU,GAAG;IACjB,QAAQ,EAAE,CAAA,GAAA,wCAA2B,CAAA;IACrC,QAAQ,EAAE,CAAA,GAAA,yCAAwB,CAAA;IAClC,WAAW,EAAE,CAAA,GAAA,yCAAoB,CAAA;CAClC,AAAC;IAEF,wCAA0B,GAAX,gCAAU;;ADVzB;AYAA,MAAM,uCAAiB,GAAQ,EAAE,AAAC;AAClC,MAAM,uCAAiB,GAAQ,EAAE,AAAC;AAClC,IAAI,yBAAG,GAAG,IAAI,AAAC;AAEA,kDAAwB,EAAO,EAAE;IAC9C,MAAM,gBAAgB,GAAG,yBAAG,GAAG,uCAAiB,GAAG,uCAAiB,AAAC;IACrE,MAAM,MAAM,GAAG,yBAAG,GAAG,KAAK,GAAG,IAAI,AAAC;IAElC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IAE1B,IAAI,gBAAgB,CAAC,MAAM,KAAK,CAAC,EAC/B,cAAc,CAAC,IAAM;QACnB,yBAAG,GAAG,MAAM,CAAC;QACb,gBAAgB,CAAC,OAAO,CAAC,CAAC,EAAO,GAAK,EAAE,EAAE,CAAC,CAAC;QAC5C,gBAAgB,CAAC,MAAM,GAAG,CAAC,CAAC;KAC7B,CAAC,CAAC;CAEN;;ADjBD;AEAA,MAAM,wCAAkB,GAAQ,EAAE,AAAC;AACnC,MAAM,wCAAkB,GAAQ,EAAE,AAAC;AACnC,IAAI,yBAAG,GAAG,IAAI,AAAC;AAEA,kDAAyB,EAAO,EAAE;IAC/C,MAAM,iBAAiB,GAAG,yBAAG,GAAG,wCAAkB,GAAG,wCAAkB,AAAC;IACxE,MAAM,MAAM,GAAG,yBAAG,GAAG,KAAK,GAAG,IAAI,AAAC;IAElC,iBAAiB,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IAE3B,IAAI,iBAAiB,CAAC,MAAM,KAAK,CAAC,EAChC,cAAc,CAAC,IAAM;QACnB,yBAAG,GAAG,MAAM,CAAC;QACb,iBAAiB,CAAC,OAAO,CAAC,CAAC,EAAO,GAAK,EAAE,EAAE,CAAC,CAAC;QAC7C,iBAAiB,CAAC,MAAM,GAAG,CAAC,CAAC;KAC9B,CAAC,CAAC;CAEN;;;AFNc,kDACb,MAA4B,EAC5B,OAAyC,EACzC,EAAkB,EAClB,MAAyB,EACzB,QAAsB,EACtB;IACA,IAAI,MAAM,KAAK,OAAO,EACpB,MAAM,CAAC,qBAAqB,EAAE,CAAC;SAC1B,IAAI,MAAM,KAAK,OAAO,EAAE;QAC7B,MAAM,CAAC,qBAAqB,EAAE,CAAC;QAC/B,IAAI,MAAM,CAAC,qBAAqB,IAAI,CAAC,EAAE;YACrC,oEAAoE;YACpE,MAAM,CAAC,qBAAqB,GAAG,CAAC,CAAC;YACjC,gCAAU,CAAC,MAAM,CAAC,IAAI,CAAgC,CACpD,MAAM,EACN,OAAO,EACP,EAAE,EACF,QAAQ,CACT,CAAC;SACH;KACF;CACF;AAED,MAAM,gCAAU,GAAG;IACjB,IAAI,EAAE,CACJ,MAA4B,EAC5B,OAAyC,EACzC,EAAkB,EAClB,QAAsB,GACnB,OAAO,CAAC,MAAM,EAAE,EAAE,EAAE,QAAQ,CAAE;IACnC,KAAK,EAAE,CACL,MAA4B,EAC5B,OAAyC,EACzC,EAAkB,EAClB,QAAsB,GACnB,CAAA,GAAA,wCAAc,CAAA,CAAC,IAAM,OAAO,CAAC,MAAM,EAAE,EAAE,EAAE,QAAQ,CAAE,CAAC;IACzD,MAAM,EAAE,CACN,MAA4B,EAC5B,OAAyC,EACzC,EAAkB,EAClB,QAAsB,GACnB,CAAA,GAAA,wCAAe,CAAA,CAAC,IAAM,OAAO,CAAC,MAAM,EAAE,EAAE,EAAE,QAAQ,CAAE,CAAC;CAC3D,AAAC;;;AGtDF;AAGe,kDAA8B,MAA4B,EAAE;IACzE,MAAM,YAAY,GAAG,CAAA,GAAA,yCAAc,CAAA,CAAC,CAAA,GAAA,yCAAc,CAAA,CAAC,MAAM,GAAG,CAAC,CAAC,AAAC;IAC/D,IAAI,YAAY,EAAE;QAChB,oEAAoE;QACpE,iBAAiB;QACjB,+EAA+E;QAC/E,YAAY,CAAC,UAAU,EAAE,CAAC;QAC1B,gFAAgF;QAChF,MAAM,CAAC,QAAQ,GAAG,YAAY,CAAC,UAAU,CAAC;QAC1C,sGAAsG;QACtG,MAAM,CAAC,KAAK,GAAG,AAAC,YAAY,CAAC,KAAK,GAAc,CAAC,CAAC;QAClD,kDAAkD;QAClD,MAAM,CAAC,WAAW,GAAG,YAAY,CAAC,WAAW,CAAC;QAC9C,gEAAgE;QAChE,MAAM,CAAC,sBAAsB,GAAG;eAC1B,YAAY,CAAC,sBAAsB;SACxC,CAAC;QAEF,kDAAkD;QAClD,yGAAyG;QACzG,qFAAqF;QACrF,+GAA+G;QAC/G,IAAI,kCAAkC,GACpC,MAAM,CAAC,sBAAsB,CAAC,MAAM,AAAC;QACvC,IAAI,kCAAkC,KAAK,MAAM,CAAC,KAAK,EACrD,MAAM,CAAC,sBAAsB,CAAC,kCAAkC,GAAG,CAAC,CAAC,GACnE,MAAM,CAAC,QAAQ,CAAC;aACb,IAAI,kCAAkC,GAAG,MAAM,CAAC,KAAK,EAC1D,MAAM,CAAC,sBAAsB,CAAC,kCAAkC,CAAC,GAC/D,MAAM,CAAC,QAAQ,CAAC;aACb,IAAI,kCAAkC,GAAG,MAAM,CAAC,KAAK,EAAE;YAC5D,MAAM,CAAC,sBAAsB,CAAC,GAAG,EAAE,CAAC;YACpC,MAAM,CAAC,sBAAsB,CAAC,kCAAkC,GAAG,CAAC,CAAC,GACnE,MAAM,CAAC,QAAQ,CAAC;SACnB;KACF,MAAM;QACL,kEAAkE;QAClE,MAAM,CAAC,KAAK,GAAG,CAAC,CAAC;QACjB,MAAM,CAAC,QAAQ,GAAG,CAAC,CAAC;QACpB,MAAM,CAAC,sBAAsB,GAAG;AAAC,aAAC;SAAC,CAAC;QACpC,MAAM,CAAC,WAAW,GAAG,IAAI,GAAG,EAAE,CAAC;KAChC;CACF;;;AC3Cc,kDAAuB,MAA4B,EAAE;IAClE,qGAAqG;IACrG,IAAI,WAAW,GAAuB,MAAM,CAAC,WAAW,AAAC;IAEzD,2FAA2F;IAC3F,MAAM,CAAC,sBAAsB,EAAE,OAAO,CAAC,CAAC,IAAI,GAAK;QAC/C,IAAI,WAAW,EAAE,GAAG,CAAC,IAAI,CAAC,EACxB,WAAW,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,GAAG,EAAE,CAAC,CAAC;QAEnC,WAAW,GAAG,WAAW,EAAE,GAAG,CAAC,IAAI,CAAC,AAAe,CAAC;KACrD,CAAC,CAAC;IAEH,2EAA2E;IAC3E,IAAI,WAAW,EAAE,GAAG,CAAC,CAAC,CAAC,EACrB,WAAW,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,GAAG,EAAE,CAAC,CAAC;CAEjC;;;AfNc,kDACb,IAAiC,EACjC,QAAiD,EACjD,EAAkB,EAClB,QAAsB,EACtB;IACA,MAAM,OAAO,GAAG,CAAA,GAAA,wCAAU,CAAA,CAAC,QAAQ,CAAC,AAAC;IAErC,MAAM,MAAM,GAA+B;QACzC,kDAAkD;QAClD,QAAQ,EAAE,IAAI;cAEd,AADA,sDAAsD;QACtD,IAAI;kBAEJ,AADA,oEAAoE;QACpE,QAAQ;QACR,kCAAkC;QAClC,UAAU,EAAE,CAAC;QACb,mFAAmF;QACnF,QAAQ,EAAE,IAAI;QACd,2DAA2D;QAC3D,KAAK,EAAE,IAAI;QACX,6FAA6F;QAC7F,WAAW,EAAE,IAAI;QACjB,sFAAsF;QACtF,sBAAsB,EAAE,IAAI;QAC5B,gGAAgG;QAChG,0BAA0B,EAAE,IAAI,GAAG,EAAE;QACrC,iGAAiG;QACjG,qBAAqB,EAAE,CAAC;QACxB,2FAA2F;QAC3F,0CAA0C;QAC1C,UAAU,EAAE,CAAC,MAAyB,GACpC,CAAA,GAAA,wCAAU,CAAA,CACR,MAAM,EACN,OAAO,EACP,EAAE,EACF,MAAM,EACN,QAAQ,CACT;KACJ,AAAC;IAEF,oGAAoG;IACpG,kDAAkD;IAClD,CAAA,GAAA,wCAAoB,CAAA,CAAC,MAAM,CAAC,CAAC;IAC7B,4DAA4D;IAC5D,CAAA,GAAA,wCAAa,CAAA,CAAC,MAAM,CAAC,CAAC;IAEtB,oDAAoD;IACpD,OAAO;QAAC,OAAO;QAAE,MAAM;KAAC,CAAU;CACnC;;AD7DD;AAQe,kDAGb,EAAkB,EAAE,QAAqB,EAAE,OAAuB,EAAE;IACpE,MAAM,CAAC,OAAO,EAAE,MAAM,CAAC,GAAG,CAAA,GAAA,wCAAY,CAAA,CAAC,MAAM,EAAE,aAAa,EAAE,EAAE,EAAE,QAAQ,CAAC,AAAC;IAE5E,mDAAmD;IACnD,OAAO,OAAO,CACZ,MAAM,EACN,EAAE,EACF,QAAQ,EACR,OAAO,CACR,CAAqC;CACvC;;;AiBrBD;AAGe,kDACb,EAAkB,EAClB,QAAsB,EACtB,OAAuB,EACvB;IACA,kFAAkF;IAClF,wCAAwC;IACxC,MAAM,QAAQ,GAAG,OAAO,QAAQ,KAAK,WAAW,GAAG,UAAU,GAAG,UAAU,AAAC;IAE3E,MAAM,CAAC,OAAO,EAAE,MAAM,CAAC,GAAG,CAAA,GAAA,wCAAY,CAAA,CAAC,MAAM,EAAE,QAAQ,EAAE,EAAE,EAAE,QAAQ,CAAC,AAAC;IAEvE,mDAAmD;IACnD,OAAO,OAAO,CAAC,MAAM,EAAE,EAAE,EAAE,QAAQ,EAAG,OAAO,CAAC,CAA0B;CACzE;;;;;AnBHD,MAAM,uBAAC,SAAS,CAAA,GAAA,qBAAc,CAAA;IAQ5B,YAAY,QAAkB,CAAE;QAC9B,KAAK,CAAC,QAAQ,CAAC,CAAC;QAEhB,8EAA8E;QAC9E,IAAI,CAAC,UAAU,GAAG,YAAY,CAAC;QAC/B,mDAAmD;QACnD,4DAA4D;QAC5D,2GAA2G;QAC3G,IAAI,CAAC,QAAQ,GAAG,EAAE,CAAC;QACnB,IAAI,CAAC,SAAS,GAAG,IAAM,CAAA,GAAA,gCAAI,CAAA,CAAC,CAAC,CAAC;QAC9B,oCAAoC;QACpC,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;KACrB;IAED,AAAU,YAAY,GAAS;QAC7B,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,OAAO,GAAK,OAAO,EAAE,CAAC,CAAC;KAC/C;IAED,uBAAuB;IACvB,cAAc,CAAC,KAAU,EAAE;QACzB,IAAK,MAAM,IAAI,IAAI,KAAK,CACtB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC,IAAI,CAAC,CAAC;QAGjC,OAAO,IAAI,CAAC,MAAM,EAAE,CAAC;KACtB;IAED,wCAAwC;IACxC,UAAU,CACR,KAAU,EACV,IAAe,EACf,SAA6D,EAC7D;QACA,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QAEnB,OAAO,IAAI,CAAC,mBAAmB,CAAC,SAAS,EAAE,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;KACzE;IAED,mBAAmB,CACjB,SAA6D,EAC7D,MAAY,EACZ,KAAU,EACV;QACA,oGAAoG;QACpG,IAAI,MAAM,AAAsB,AAAC;QACjC,4EAA4E;QAC5E,IAAI,CAAC,QAAQ,CAAC,IAAI,CAChB,CAAA,GAAA,wCAAe,CAAA,CAAC,IAAO,MAAM,GAAG,SAAS,CAAC,KAAK,EAAE,MAAM,CAAC,AAAC,EAAE,EAAE,CAAC,CAC/D,CAAC;QAEF,MAAM,CACJ,gBAAgB,EAChB,yBAAyB,EACzB,CAAC,kBAAkB,CAAC,GACrB,GAAQ,CAAA,GAAA,wCAAsB,CAAA,CAC7B,CAAC,CAAC,EAAE,uBAA0C,GAAK;YACjD,IAAI,CAAC,QAAQ,CAAC,uBAAuB,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;SAC7C,EACD;YAAC,MAAM;SAAE,EACT;YAAE,KAAK,EAAE,IAAI;YAAE,WAAW,EAAE,IAAI;SAAE,CACnC,AAAC;QAEF,mBAAmB;QACnB,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;QACrC,uGAAuG;QACvG,sBAAsB;QACtB,IAAI,CAAC,yBAAyB,GAAG,yBAAyB,CAAC;QAE3D,IAAI,CAAC,SAAS,GAAG,IAAM;YACrB,gFAAgF;YAChF,IAAI,IAAI,CAAC,OAAO,EAAE;gBAChB,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;gBACrB,CAAA,GAAA,wCAAwB,CAAA,CAAC,IAAI,CAAC,CAAC;gBAC/B,MAAM,CAAC,kBAAkB,CAAC,GAAG,IAAI,CAAC,yBAAyB,IAAI,AAAC;gBAEhE,OAAO,kBAAkB,CAAC;aAC3B,MACC,OAAO,GAAA,eAAQ,CAAC;SAEnB,CAAC;QACF,oFAAoF;QACpF,IAAI,CAAC,UAAU,GAAG,gBAAgB,CAAC;QAEnC,OAAO,kBAAkB,CAAC;KAC3B;IAED,MAAM,CACJ,IAAe,EACf,CAAC,SAAS,EAAE,KAAK,CAGhB,EACD;QACA,qHAAqH;QACrH,OAAO,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,KAAK,EAAE,IAAI,EAAE,SAAS,CAAC,CAAC;KACtD;IAED,AAAU,WAAW,GAAS;QAC5B,IAAI,CAAC,UAAU,GAAG,YAAY,CAAC;KAChC;IAED,MAAM,GAAG;QACP,OAAO,IAAI,CAAC,SAAS,EAAE,CAAC;KACzB;CACF;AAYD,MAAM,uBAAC,GAAe,CAAA,GAAA,gBAAS,CAAA,CAAC,uBAAC,CAAC,AAAC;IAEnC,wCAAiB,GAAF,uBAAC;;;AD/HT,SAAS,yCAAM,CACpB,SAGE,EACF,KAGC,EACe;IAChB,kEAAkE;IAClE,cAAc;IACd,IACE,OAAO,KAAK,CAAC,eAAe,KAAK,QAAQ,IACzC,KAAK,CAAC,eAAe,YAAY,MAAM,EAEvC,KAAK,CAAC,eAAe,GAAG,QAAQ,CAAC,aAAa,CAC5C,KAAK,CAAC,eAAe,CACtB,CAAC;IAEJ,MAAM,eAAe,GAAG,IACtB,CAAA,GAAA,aAAc,CAAA,CACZ,CAAA,GAAA,gCAAI,CAAA,CAAC,EAAE,CAAA,GAAA,wCAAC,CAAA,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC,CAAC,EAC5B,KAAK,CAAC,eAAe,EACrB,KAAK,CAAC,aAAa,CACpB,AAAC;IAEJ,gFAAgF;IAChF,cAAc,CAAC,eAAe,CAAC,CAAC;IAEhC,uEAAuE;IACvE,iBAAiB;IACjB,OAAO,eAAe,CAAC;CACxB;;AD7CD;;;AuBAA;AAIA,SAAS,+BAAS,CAChB,KAA6B,EAC7B,MAA4B,EAC5B;IACA,oEAAoE;IACpE,MAAM,mBAAmB,GAAG,KAAK,CAAC,mBAAmB,AAAC;IACtD,MAAM,IAAI,GAAG,MAAM,CAAC,IAAI,AAAC;IAEzB,uFAAuF;IACvF,6DAA6D;IAC7D,IAAI,MAAM,CAAC,QAAQ,KAAK,UAAU,EAAE,OAAO;IAE3C,2FAA2F;IAC3F,wBAAwB;IACxB,IAAI,IAAI,KAAK,OAAO,IAAI,IAAI,KAAK,QAAQ,EAAE;QACzC,mCAAmC;QACnC,KAAK,CAAC,2BAA2B,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;QAC9C,MAAM,CAAC,0BAA0B,CAAC,GAAG,CAAC,KAAK,CAAC,2BAA2B,CAAC,CAAC;KAC1E,MAAM;QACL,iCAAiC;QACjC,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC,mBAAmB,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;QAC/D,MAAM,CAAC,0BAA0B,CAAC,GAAG,CACnC,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC,mBAAmB,CAAC,CACnD,CAAC;KACH;CACF;AAEc,kDAAsB,KAA6B,EAAE;IAClE,MAAM,aAAa,GAAG,CAAA,GAAA,yCAAc,CAAA,CAAC,CAAA,GAAA,yCAAc,CAAA,CAAC,MAAM,GAAG,CAAC,CAAC,AAAC;IAChE,IAAI,aAAa,EACf,+BAAS,CAAC,KAAK,EAAE,aAAa,CAAC,CAAC;IAGlC,OAAO,KAAK,CAAC,KAAK,CAAC;CACpB;;ADtCD;AGAA,MAAM,wCAAkB,GAAmB,EAAE,AAAC;AAEvC,SAAS,yCAAmB,CAAC,eAA2B,EAAE;IAC/D,wCAAkB,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;CAC1C;AAEM,SAAS,yCAAkB,GAAG;IACnC,wCAAkB,CAAC,OAAO,CAAC,CAAC,eAAe,GAAK,eAAe,EAAE,CAAC,CAAC;IACnE,wCAAkB,CAAC,MAAM,GAAG,CAAC,CAAC;CAC/B;;ADTD;AEEA,SAAS,yCAAgB,CACvB,KAA0B,EAC1B,mBAAkC,EAClC;IACA,KAAK,CAAC,iBAAiB,CAAC,mBAAmB,CAAC,CAAC,OAAO,CAAC,CAAC,YAAY,GAAK;QACrE,YAAY,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;KAClC,CAAC,CAAC;IAEH,KAAK,CAAC,iBAAiB,CAAC,mBAAmB,CAAC,CAAC,OAAO,CAAC,CAAC,YAAY,GAAK;QACrE,YAAY,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;KAClC,CAAC,CAAC;IAEH,KAAK,CAAC,2BAA2B,CAAC,OAAO,CAAC,CAAC,YAAY,GAAK;QAC1D,YAAY,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;KAClC,CAAC,CAAC;CACJ;AAED,SAAS,yCAAgB,CACvB,KAA0B,EAC1B,mBAAkC,EAClC;IACA,KAAK,CAAC,iBAAiB,CAAC,mBAAmB,CAAC,CAAC,OAAO,CAAC,CAAC,YAAY,GAAK;QACrE,YAAY,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;KAClC,CAAC,CAAC;IAEH,KAAK,CAAC,iBAAiB,CAAC,mBAAmB,CAAC,CAAC,OAAO,CAAC,CAAC,YAAY,GAAK;QACrE,YAAY,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;KAClC,CAAC,CAAC;IAEH,KAAK,CAAC,2BAA2B,CAAC,OAAO,CAAC,CAAC,YAAY,GAAK;QAC1D,YAAY,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;KAClC,CAAC,CAAC;CACJ;;;AF9Bc,kDACb,KAA6B,EAC7B,SAA+B,EAC/B;IACA,qEAAqE;IACrE,MAAM,mBAAmB,GAAG,KAAK,CAAC,mBAAmB,AAAC;IACtD,6BAA6B;IAC7B,KAAK,CAAC,mBAAmB,GAAG,mBAAmB,KAAK,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC;IAE1E,mFAAmF;IACnF,sBAAsB;IACtB,CAAA,GAAA,yCAAgB,CAAA,CAAC,KAAK,EAAE,mBAAmB,CAAC,CAAC;IAE7C,oBAAoB;IACpB,KAAK,CAAC,KAAK,GACT,OAAO,SAAS,KAAK,UAAU,GAC3B,AAAC,SAAS,CAAoB,KAAK,CAAC,KAAK,CAAE,GAC3C,SAAS,CAAC;IAEhB,4FAA4F;IAC5F,kDAAkD;IAClD,CAAA,GAAA,yCAAgB,CAAA,CAAC,KAAK,EAAE,mBAAmB,CAAC,CAAC;IAE7C,wHAAwH;IACxH,CAAA,GAAA,yCAAkB,CAAA,EAAE,CAAC;CACtB;;;AFvBM,SAAS,wCAAU,CAAI,YAA4B,EAAY;IACpE,sDAAsD;IACtD,MAAM,KAAK,GAA2B;QACpC,mCAAmC;QACnC,0FAA0F;QAC1F,qDAAqD;QACrD,iBAAiB,EAAE;YACjB,GAAG,EAAE,IAAI,GAAG,EAAE;YACd,GAAG,EAAE,IAAI,GAAG,EAAE;SACf;QACD,4BAA4B;QAC5B,0FAA0F;QAC1F,mDAAmD;QACnD,iBAAiB,EAAE;YACjB,GAAG,EAAE,IAAI,GAAG,EAAE;YACd,GAAG,EAAE,IAAI,GAAG,EAAE;SACf;QACD,+CAA+C;QAC/C,kDAAkD;QAClD,2BAA2B,EAAE,IAAI,GAAG,EAAE;QACtC,2FAA2F;QAC3F,mBAAmB,EAAE,KAAK;QAC1B,KAAK,EACH,OAAO,YAAY,KAAK,UAAU,GAC9B,AAAC,YAAY,EAAc,GAC3B,YAAY;KACnB,AAAC;IAEF,MAAM,MAAM,GAAG,IAAM,CAAA,GAAA,wCAAG,CAAA,CAAC,KAAK,CAAC,AAAC;IAChC,MAAM,MAAM,GAAG,CAAC,SAA+B,GAAK,CAAA,GAAA,wCAAG,CAAA,CAAC,KAAK,EAAE,SAAS,CAAC,AAAC;IAE1E,OAAO;QAAC,MAAM;QAAE,MAAM;KAAC,CAAa;CACrC;;;AKpCc,kDAAkB,KAAe,EAAE;IAChD,SAAS,YAAY,CAAC,SAAgC,EAAE;QACtD,IAAI,SAAS,KAAK,SAAS,EACzB,OAAO,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC;aAElB,OAAO,KAAK,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC;KAE9B;IACD,OAAO,YAAY,CAAoB;CACxC;;;ACXD;AAGe,kDACb,EAAkB,EAClB,QAAsB,EACtB,OAAuB,EACvB;IACA,kFAAkF;IAClF,wCAAwC;IACxC,MAAM,QAAQ,GAAG,OAAO,QAAQ,KAAK,WAAW,GAAG,UAAU,GAAG,UAAU,AAAC;IAE3E,MAAM,CAAC,OAAO,EAAE,MAAM,CAAC,GAAG,CAAA,GAAA,wCAAY,CAAA,CAAC,QAAQ,EAAE,QAAQ,EAAE,EAAE,EAAE,QAAQ,CAAC,AAAC;IAEzE,iFAAiF;IACjF,8DAA8D;IAC9D,OAAO,IAAI,OAAO,CAAa,CAAC,OAAO,GACrC,UAAU,CAAC,IAAM;YACf,OAAO,CAAC,OAAO,CAAC,MAAM,EAAE,EAAE,EAAE,QAAQ,EAAG,OAAO,CAAC,CAA0B,CAAC;SAC3E,CAAC,CACH,CAAC;CACH;;;ACrBD;AAGe,kDACb,EAAkB,EAClB,QAAsB,EACtB,OAAuB,EACvB;IACA,kFAAkF;IAClF,wCAAwC;IACxC,MAAM,QAAQ,GAAG,OAAO,QAAQ,KAAK,WAAW,GAAG,UAAU,GAAG,UAAU,AAAC;IAE3E,MAAM,CAAC,OAAO,EAAE,MAAM,CAAC,GAAG,CAAA,GAAA,wCAAY,CAAA,CAAC,QAAQ,EAAE,QAAQ,EAAE,EAAE,EAAE,QAAQ,CAAC,AAAC;IAEzE,kFAAkF;IAClF,8DAA8D;IAC9D,OAAO,IAAI,OAAO,CAAa,CAAC,OAAO,GAAK;QAC1C,cAAc,CAAC,IACb,OAAO,CAAC,OAAO,CAAC,MAAM,EAAE,EAAE,EAAE,QAAQ,EAAG,OAAO,CAAC,CAA0B,CAC1E,CAAC;KACH,CAAC,CAAC;CACJ;;;;AGrBD;;;;;AAOO,SAAS,yCAAsB,CAAC,IAAwB,EAAE;IAC/D,qEAAqE;IACrE,MAAM,mBAAmB,GAAG,IAAI,CAAC,mBAAmB,AAAC;IACrD,6BAA6B;IAC7B,IAAI,CAAC,mBAAmB,GAAG,mBAAmB,KAAK,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC;IAEzE,mFAAmF;IACnF,sBAAsB;IACtB,CAAA,GAAA,yCAAgB,CAAA,CAAC,IAAI,EAAE,mBAAmB,CAAC,CAAC;CAC7C;AAGM,SAAS,yCAAoC,CAClD,IAAwB,EACxB,EAAuB,EACvB;IACA,sGAAsG;IACtG,IAAI,CAAC,UAAU,GAAG,CAAC,CAAC;IAEpB,iDAAiD;IACjD,MAAM,UAAU,GAAG,CAAA,GAAA,wCAAc,CAAA,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC,AAElC,AAAC;IACd,IAAI,UAAU,EACZ,KAAK,MAAM,OAAO,IAAI,UAAU,CAAE;QAChC,mHAAmH;QACnH,2EAA2E;QAC3E,IAAI,OAAO,OAAO,KAAK,UAAU,EAC/B,OAAO,OAAO,CAAC;QAEjB,OAAO,EAAE,CAAC;KACX;IAEH,UAAU,EAAE,KAAK,EAAE,CAAC;IAEpB,oEAAoE;IACpE,CAAA,GAAA,yCAAc,CAAA,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAE1B,IAAI,CAAC,KAAK,GAAG,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IAE5B,IAAI,IAAI,CAAC,QAAQ,EAAE;QACjB,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;QACtB,kDAAkD;QAClD,UAAU,EAAE,GAAG,CAAC,IAAM,CAAA,GAAA,wCAA8B,CAAA,CAAC,IAAI,CAAC,CAAC,CAAC;KAC7D,MAAM;QACL,wHAAwH;QACxH,2HAA2H;QAC3H,UAAU,EAAE,GAAG,CAAC,IAAI,CAAC,CAAC;QACtB,0FAA0F;QAC1F,CAAA,GAAA,yCAAmB,CAAA,CAAC,IAAM;YACxB,UAAU,EAAE,KAAK,EAAE,CAAC;YACpB,UAAU,EAAE,GAAG,CAAC,IAAM,CAAA,GAAA,wCAA8B,CAAA,CAAC,IAAI,CAAC,CAAC,CAAC;SAC7D,CAAC,CAAC;KACJ;IAED,uEAAuE;IACvE,CAAA,GAAA,yCAAc,CAAA,CAAC,GAAG,EAAE,CAAC;IAErB,kIAAkI;IAClI,MAAM,mBAAmB,GACvB,IAAI,CAAC,mBAAmB,KAAK,KAAK,GAAG,KAAK,GAAG,KAAK,AAAC;IAErD,4FAA4F;IAC5F,kDAAkD;IAClD,CAAA,GAAA,yCAAgB,CAAA,CAAC,IAAI,EAAE,mBAAmB,CAAC,CAAC;CAC7C;;ADxED;AAMe,kDACb,IAAwB,EACxB,EAAuB,EACvB,MAAyB,EACzB;IACA,IAAI,MAAM,KAAK,OAAO,EAAE;QACtB,IAAI,CAAC,qBAAqB,EAAE,CAAC;QAC7B,IAAI,IAAI,CAAC,qBAAqB,KAAK,CAAC,EAClC,CAAA,GAAA,yCAAsB,CAAA,CAAC,IAAI,CAAC,CAAC;KAEhC,MAAM,IAAI,MAAM,KAAK,OAAO,EAAE;QAC7B,IAAI,CAAC,qBAAqB,EAAE,CAAC;QAC7B,IAAI,IAAI,CAAC,qBAAqB,IAAI,CAAC,EAAE;YACnC,kEAAkE;YAClE,IAAI,CAAC,qBAAqB,GAAG,CAAC,CAAC;YAC/B,CAAA,GAAA,yCAAoC,CAAA,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC;SAChD;KACF;CACF;;ADxBD;;;;;AAQe,kDAA4B,EAAmB,EAAa;IACzE,MAAM,IAAI,GAAuB;QAC/B,kBAAkB;QAClB,iBAAiB,EAAE;YACjB,GAAG,EAAE,IAAI,GAAG,EAAE;YACd,GAAG,EAAE,IAAI,GAAG,EAAE;SACf;QACD,iBAAiB,EAAE;YACjB,GAAG,EAAE,IAAI,GAAG,EAAE;YACd,GAAG,EAAE,IAAI,GAAG,EAAE;SACf;QACD,2BAA2B,EAAE,IAAI,GAAG,EAAE;QACtC,mBAAmB,EAAE,KAAK;QAC1B,KAAK,EAAE,SAAS;QAChB,mBAAmB;QACnB,QAAQ,EAAE,IAAI;QACd,IAAI,EAAE,MAAM;QACZ,UAAU,EAAE,CAAC;QACb,QAAQ,EAAE,IAAI;QACd,KAAK,EAAE,IAAI;QACX,WAAW,EAAE,IAAI;QACjB,sBAAsB,EAAE,IAAI;QAC5B,0BAA0B,EAAE,IAAI,GAAG,EAAE;QACrC,qBAAqB,EAAE,CAAC;QACxB,UAAU,EAAE,CAAC,MAAM,GAAK,CAAA,GAAA,wCAAU,CAAA,CAAC,IAAI,EAAE,EAAE,EAAE,MAAM,CAAC;KACrD,AAAC;IAEF,CAAA,GAAA,wCAAoB,CAAA,CAAC,IAAI,CAAC,CAAC;IAC3B,CAAA,GAAA,wCAAa,CAAA,CAAC,IAAI,CAAC,CAAC;IAEpB,MAAM,WAAW,GAAG,CAAA,GAAA,yCAAoC,CAAA,CAAC,IAAI,EAAE,EAAE,CAAC,AAAC;IAEnE,OACE,WAAW,GAAG,IAAM,CAAA,GAAA,wCAAG,CAAA,CAAI,WAAW,CAAC,GAAG,IAAM,CAAA,GAAA,wCAAG,CAAA,CAAI,IAAI,CAAC,CAC/C;CAChB;;;;;;;;;;;;;;;;;;;;;;;;;A/B3CD;AmCAA;AAWe;IAKb,YAAY,qBAAyB,CAAE;QACrC,IAAI,CAAC,SAAS,GAAG,EAAE,AAAiB,CAAC;QACrC,IAAI,CAAC,eAAe,CAAC,qBAAqB,CAAC,CAAC;QAC5C,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACnD,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACvD,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;KAC5D;IAOD,aAAa,CACX,EAAK,EACL,YAAoB,EACsB;QAC1C,IAAI,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC,KAAK,SAAS,EAClC,IAAI,CAAC,eAAe,CAAC;YACnB,CAAC,EAAE,CAAa,EAAE,YAAY;SAC/B,CAAgB,CAAC;QAGpB,OAAO,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC,CAAiB;KAC3C;IAED,AAAQ,eAAe,CAAC,cAA2B,EAAE;QACnD,IAAI,cAAc,EAChB,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,OAAO,CAAC,CAAC,aAAuB,GAAK;YAC/D,IAAI,CAAC,SAAS,CAAC,aAAa,CAAC,GAAG,CAAA,GAAA,wCAAU,CAAA,CACxC,cAAc,CAAC,aAAa,CAAC,CAC9B,AAAuB,CAAC;SAC1B,CAAC,CAAC;KAEN;IAED,eAAe,CAAC,WAAuD,EAAE;QACvE,WAAW,CAAC,OAAO,CACjB,CAAC,UAAU,GAAK,OAAO,IAAI,CAAC,SAAS,CAAC,UAAU,CAAa,CAC9D,CAAC;KACH;IAED,iBAAiB,GAAG;QAClB,MAAM,cAAc,GAAG,EAAE,AAAkB,AAAC;QAC5C,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,OAAO,CACjC,CAAC,QAAQ,GAAM,cAAc,CAAC,QAAQ,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,EAAE,AAAC,CACzE,CAAC;QAEF,OAAO,cAAc,CAAC;KACvB;IAED,YAAY,GAAG;QACb,OAAO,IAAI,CAAC,SAAS,CAAC;KACvB;CACF;;ADtED;AEkBe;IAGb,YAAY,oBAAuB,CAAE;QACnC,IAAI,CAAC,WAAW,GAAG,EAAE,AAAK,CAAC;QAC3B,IAAI,CAAC,iBAAiB,CAAC,oBAAoB,CAAC,CAAC;QAC7C,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACvD,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAC3D,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;KAChE;IAED,AAAQ,iBAAiB,CAAC,WAAuB,EAAE;QACjD,IAAI,WAAW,EACb,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,OAAO,CAAC,CAAC,UAAmB,GAAK;YACxD,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,GAAG,WAAW,CAAC,UAAU,CAAC,AAAc,CAAC;SACtE,CAAC,CAAC;KAEN;IAWD,eAAe,CACb,EAAK,EACL,mBAA0B,EACe;QACzC,IAAI,IAAI,CAAC,WAAW,CAAC,EAAE,CAAC,KAAK,SAAS,EAAE;YACtC,MAAM,oBAAoB,GAAG,IAAM,SAAS,AAAC;YAC7C,IAAI,CAAC,iBAAiB,CAAC;gBACrB,CAAC,EAAE,CAAY,EAAG,mBAAmB,IACnC,oBAAoB;aACvB,CAAe,CAAC;SAClB;QAED,OAAO,IAAI,CAAC,WAAW,CAAC,EAAE,CAAC,CAAS;KACrC;IAED,iBAAiB,CAAC,aAAwD,EAAE;QAC1E,aAAa,CAAC,OAAO,CACnB,CAAC,YAAY,GAAK,OAAO,IAAI,CAAC,WAAW,CAAC,YAAY,CAAY,CACnE,CAAC;KACH;IAED,mBAAmB,GAAG;QACpB,MAAM,gBAAgB,GAAG,EAAE,AAAuB,AAAC;QACnD,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,OAAO,CACnC,CAAC,UAAqC,GACnC,gBAAgB,CAAC,UAAU,CAAC,GAAG,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,EAAE,AAAC,CAClE,CAAC;QAEF,OAAO,gBAAgB,CAAC;KACzB;IAED,cAAc,GAAG;QACf,OAAO,IAAI,CAAC,WAAW,CAAC;KACzB;CACF;;;AC7Ec;IAGb,YAAY,OAAU,CAAE;QACtB,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACvB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;KAC1C;IAED,QAAQ,CAAC,QAAiB,EAAE,OAAkC,EAAE;QAC9D,OAAO,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,OAAO,CAAC,CAAC;KACxC;CACF;;;;;AEdD;;AAqBe;IAKb,YAAY,KAAQ,CAAE;QACpB,CAAC,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,cAAc,CAAC,GAAG,CAAA,GAAA,wCAAU,CAAA,CAClD,MAAM,CAAC,QAAQ,CAAC,QAAQ,CACzB,CAAC;QACF,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,MAAM,CAAC,gBAAgB,CAAC,UAAU,EAAE,IAAM,IAAI,CAAC,KAAK,EAAE,CAAC,CAAC;QACxD,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACnC,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;KAC1C;IAED,IAAI,GAMC,CAAC,KAAK,GAAK;QACd,MAAM,QAAQ,GAAG,CAAA,GAAA,wCAAS,CAAA,CAAC,IAAM,IAAI,CAAC,WAAW,EAAE,KAAK,KAAK,CAAC,EAAE,CAAC,AAAC;QAElE,OAAO,IACL,CAAA,GAAA,gCAAI,CAAA,CAAC;aACE,EAAE,KAAK,CAAC,EAAE,CAAC;eACT,EAAE,CAAC,CAAQ,GAAK;gBACrB,CAAC,CAAC,cAAc,EAAE,CAAC;gBACnB,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;aACzB,CAAC;cACI,EAAE,CAAA,GAAA,qCAAS,CAAA,CAAC,KAAK,CAAC,KAAK,GAAG,QAAQ,EAAE,EAAE,CAAC;cACvC,EAAE,CAAA,GAAA,qCAAS,CAAA,CAAC,KAAK,CAAC,KAAK,GAAG,QAAQ,EAAE,EAAE,CAAC;SAC5C,EAAE,KAAK,CAAC,OAAO,IAAI,KAAK,CAAC,IAAI,CAAC;OAChC,CAAC,CAAC;KACN,CAAC;IAEF,QAAQ,CAAC,UAA2B,EAAE;QACpC,IAAI,OAAO,UAAU,KAAK,QAAQ,EAChC,OAAO,CAAC,SAAS,CAAC,IAAI,EAAE,EAAE,EAAE,UAAU,CAAC,CAAC;aAExC,OAAO,CAAC,EAAE,CAAC,UAAU,CAAC,CAAC;QAGzB,IAAI,CAAC,KAAK,EAAE,CAAC;KACd;IAED,KAAK,GAAG;QACN,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;KAC/C;IAED,MAAM,GAKD,CAAC,KAAK,GAAK;QACd,OAAO,IACL,CAAA,GAAA,gCAAI,CAAA,CAAC,EAAE,CAAA,GAAA,kCAAM,CAAA,CAAC,IAAI,CAAC,WAAW,EAAE,EAAE,KAAK,CAAC,MAAM,EAAE,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;KACpE,CAAC;IAEF,QAAQ,CAAC,KAAa,EAAE;QACtB,QAAQ,CAAC,KAAK,GAAG,KAAK,CAAC;KACxB;CACF;;ADrFD;;","sources":["src/promethium-js.ts","src/nqtui/index.ts","src/nqtui/render.ts","src/nqtui/h.ts","src/nqtui/queueRevertChangedToTrue.ts","src/nqtui/adaptations/adaptEffect/adaptComponentFnEffect.ts","src/nqtui/adaptations/adaptEffect/createEffect.ts","src/nqtui/adaptations/adaptEffect/executeFns.ts","src/nqtui/adaptations/adaptEffect/implicitDependencyExecuteFn.ts","src/nqtui/adaptations/adaptEffect/baseExecuteFn.ts","src/nqtui/adaptations/effectContexts.ts","src/nqtui/adaptations/getCleanupNode.ts","src/nqtui/adaptations/observableSubscriptionsCleanup.ts","src/nqtui/adaptations/adaptEffect/effectAndDescendantCeanup.ts","src/nqtui/adaptations/adaptEffect/dependencyArrayExecuteFn.ts","src/nqtui/adaptations/adaptEffect/componentFnExecuteFn.ts","src/nqtui/adaptations/adaptEffect/updateEffectDependencies.ts","src/nqtui/adaptations/adaptEffect/sendSignal.ts","src/nqtui/adaptations/adaptEffect/addAsyncEffect.ts","src/nqtui/adaptations/adaptEffect/addRenderEffect.ts","src/nqtui/adaptations/setInitialParameters.ts","src/nqtui/adaptations/setCleanupSet.ts","src/nqtui/adaptations/adaptEffect/adaptSyncEffect.ts","src/nqtui/adaptations/adaptState/adaptState.ts","src/nqtui/adaptations/get.ts","src/nqtui/adaptations/adaptState/set.ts","src/nqtui/adaptations/cleanupUpdateFns.ts","src/nqtui/adaptations/sendSignals.ts","src/nqtui/adaptations/adaptState/unify.ts","src/nqtui/adaptations/adaptEffect/adaptEffect.ts","src/nqtui/adaptations/adaptEffect/adaptRenderEffect.ts","src/nqtui/adaptations/adaptMemo/adaptMemo.ts","src/nqtui/adaptations/adaptMemo/sendSignal.ts","src/nqtui/adaptations/adaptMemo/notifyAndUpdate.ts","src/nqtx/index.ts","src/nqtx/ParticleEntity.ts","src/nqtx/DerivativeEntity.ts","src/nqtx/ActionEntity.ts","src/nqtrouter/index.ts","src/nqtrouter/Router.ts"],"sourcesContent":["import type {\n  Component,\n  Getter,\n  Setter,\n  State,\n  UnifiedState,\n  EffectFn,\n  EffectOptions,\n  DepArray,\n  TemplateResult,\n  DirectiveResult,\n} from \"./nqtui\";\nimport {\n  render,\n  h,\n  html,\n  adaptState,\n  unify,\n  adaptEffect,\n  adaptRenderEffect,\n  adaptSyncEffect,\n  adaptMemo,\n  classMap,\n  styleMap,\n  when,\n  choose,\n  map,\n  repeat,\n  join,\n  range,\n  ifDefined,\n  cache,\n  keyed,\n  guard,\n  live,\n  ref,\n  createRef,\n  templateContent,\n  unsafeHTML,\n  unsafeSVG,\n  until,\n  asyncAppend,\n  asyncReplace,\n} from \"./nqtui\";\n\nimport type { Deletable } from \"./nqtx\";\nimport { ParticleEntity, DerivativeEntity, ActionEntity } from \"./nqtx\";\n\nimport { Router } from \"./nqtrouter\";\n\nexport {\n  Component,\n  Getter,\n  Setter,\n  State,\n  UnifiedState,\n  EffectFn,\n  EffectOptions,\n  DepArray,\n  TemplateResult,\n  DirectiveResult,\n  render,\n  h,\n  html,\n  adaptState,\n  unify,\n  adaptEffect,\n  adaptRenderEffect,\n  adaptSyncEffect,\n  adaptMemo,\n  classMap,\n  styleMap,\n  when,\n  choose,\n  guard,\n  cache,\n  keyed,\n  map,\n  repeat,\n  join,\n  range,\n  live,\n  ifDefined,\n  ref,\n  createRef,\n  templateContent,\n  unsafeHTML,\n  unsafeSVG,\n  until,\n  asyncAppend,\n  asyncReplace,\n};\n\nexport { ParticleEntity, DerivativeEntity, ActionEntity, Deletable };\n\nexport { Router };\n","import type { TemplateResult } from \"lit-html\";\nimport type { DirectiveResult } from \"lit-html/directive.js\";\nimport type { Component } from \"./render\";\nimport type {\n  Getter,\n  Setter,\n  State,\n  UnifiedState,\n} from \"./adaptations/adaptState/stateTypes\";\nimport type {\n  EffectFn,\n  EffectOptions,\n  DepArray,\n} from \"./adaptations/adaptEffect/effectTypes\";\nimport { render } from \"./render\";\nimport h from \"./h\";\nimport { html } from \"lit-html\";\nimport { adaptState } from \"./adaptations/adaptState/adaptState\";\nimport unify from \"./adaptations/adaptState/unify\";\nimport adaptEffect from \"./adaptations/adaptEffect/adaptEffect\";\nimport adaptRenderEffect from \"./adaptations/adaptEffect/adaptRenderEffect\";\nimport adaptSyncEffect from \"./adaptations/adaptEffect/adaptSyncEffect\";\nimport adaptMemo from \"./adaptations/adaptMemo/adaptMemo\";\nimport { classMap } from \"lit-html/directives/class-map.js\";\nimport { styleMap } from \"lit-html/directives/style-map.js\";\nimport { when } from \"lit-html/directives/when.js\";\nimport { choose } from \"lit-html/directives/choose.js\";\nimport { map } from \"lit-html/directives/map.js\";\nimport { repeat } from \"lit-html/directives/repeat.js\";\nimport { join } from \"lit-html/directives/join.js\";\nimport { range } from \"lit-html/directives/range.js\";\nimport { ifDefined } from \"lit-html/directives/if-defined.js\";\nimport { cache } from \"lit-html/directives/cache.js\";\nimport { keyed } from \"lit-html/directives/keyed.js\";\nimport { guard } from \"lit-html/directives/guard.js\";\nimport { live } from \"lit-html/directives/live.js\";\nimport { ref } from \"lit-html/directives/ref.js\";\nimport { createRef } from \"lit-html/directives/ref.js\";\nimport { templateContent } from \"lit-html/directives/template-content.js\";\nimport { unsafeHTML } from \"lit-html/directives/unsafe-html.js\";\nimport { unsafeSVG } from \"lit-html/directives/unsafe-svg.js\";\nimport { until } from \"lit-html/directives/until.js\";\nimport { asyncAppend } from \"lit-html/directives/async-append.js\";\nimport { asyncReplace } from \"lit-html/directives/async-replace.js\";\n\nexport {\n  Component,\n  Getter,\n  Setter,\n  State,\n  UnifiedState,\n  EffectFn,\n  EffectOptions,\n  DepArray,\n  render,\n  TemplateResult,\n  DirectiveResult,\n  h,\n  html,\n  adaptState,\n  unify,\n  adaptEffect,\n  adaptRenderEffect,\n  adaptSyncEffect,\n  adaptMemo,\n  classMap,\n  styleMap,\n  when,\n  choose,\n  guard,\n  cache,\n  keyed,\n  map,\n  repeat,\n  join,\n  range,\n  live,\n  ifDefined,\n  ref,\n  createRef,\n  templateContent,\n  unsafeHTML,\n  unsafeSVG,\n  until,\n  asyncAppend,\n  asyncReplace,\n};\n","import {\n  render as internalRender,\n  html,\n  TemplateResult,\n  RootPart,\n} from \"lit-html\";\nimport h from \"./h\";\n\nexport type Component<T = null> = T extends null\n  ? (props?: null) => () => TemplateResult\n  : (props: T) => () => TemplateResult;\n\nexport function render(\n  Component: Component<{\n    renderContainer: string | HTMLElement | DocumentFragment;\n    renderOptions?: Object;\n  }>,\n  props: {\n    renderContainer: string | HTMLElement | DocumentFragment;\n    renderOptions?: Object;\n  }\n): () => RootPart {\n  //check whether or not \"renderContainer\" is a string and handle it\n  //accordingly.\n  if (\n    typeof props.renderContainer === \"string\" ||\n    props.renderContainer instanceof String\n  )\n    props.renderContainer = document.querySelector(\n      props.renderContainer as any\n    );\n\n  const renderComponent = () =>\n    internalRender(\n      html`${h(Component, props)}`,\n      props.renderContainer as HTMLElement | DocumentFragment,\n      props.renderOptions\n    );\n\n  //queue microtask to render the component to enable all extensions to run first.\n  queueMicrotask(renderComponent);\n\n  //return \"renderComponent\" function to allow re-rendering of whole root\n  //component tree.\n  return renderComponent;\n}\n","import {\n  AsyncDirective,\n  directive,\n  DirectiveResult,\n  PartInfo,\n} from \"lit-html/async-directive.js\";\nimport queueRevertChangedToTrue from \"./queueRevertChangedToTrue\";\nimport adaptComponentFnEffect from \"./adaptations/adaptEffect/adaptComponentFnEffect\";\nimport adaptSyncEffect from \"./adaptations/adaptEffect/adaptSyncEffect\";\nimport { ChildPart, noChange, TemplateResult, html } from \"lit-html\";\nimport { Component } from \"./render\";\nimport { EffectOptions } from \"./adaptations/adaptEffect/effectTypes\";\n\nclass $ extends AsyncDirective {\n  updateFlag: \"initialize\" | \"externalRender\";\n  cleanups: any[];\n  ComponentDependencyUpdate: any;\n  Component: () => TemplateResult;\n  changed: boolean;\n  props: any;\n\n  constructor(partInfo: PartInfo) {\n    super(partInfo);\n\n    //boolean flag to enable initialization of the component in the update method.\n    this.updateFlag = \"initialize\";\n    //initialize cleanups for component. this includes:\n    //1. general component cleanup for all its effects and memos\n    //2. cleanup of the effect created from the function (that returns a template result) the component returns\n    this.cleanups = [];\n    this.Component = () => html``;\n    //initialize \"changed\" flag as true.\n    this.changed = true;\n  }\n\n  protected disconnected(): void {\n    this.cleanups.forEach((cleanup) => cleanup());\n  }\n\n  //normal render process\n  externalRender(props: any) {\n    for (const prop in props) {\n      this.props[prop] = props[prop];\n    }\n\n    return this.render();\n  }\n\n  //first time initialization of component\n  initialize(\n    props: any,\n    part: ChildPart,\n    Component: (props: any, parent: Node) => () => TemplateResult\n  ) {\n    this.props = props;\n\n    return this.initializeComponent(Component, part.parentNode, this.props);\n  }\n\n  initializeComponent(\n    Component: (props: any, parent: Node) => () => TemplateResult,\n    parent: Node,\n    props: any\n  ) {\n    //store the function (that returns a template result) the component returns in `htmlFn` for later us\n    let htmlFn: () => TemplateResult;\n    //initialize component effects and memos and store the cleanup (1st cleanup)\n    this.cleanups.push(\n      adaptSyncEffect(() => (htmlFn = Component(props, parent)), [])\n    );\n\n    const [\n      ComponentCleanup,\n      ComponentDependencyUpdate,\n      [htmlTemplateResult],\n    ]: any = adaptComponentFnEffect(\n      (_, htmlTemplateResultArray?: [TemplateResult]) => {\n        this.setValue(htmlTemplateResultArray?.[0]);\n      },\n      [htmlFn!],\n      { defer: true, isComponent: true } as EffectOptions // check `effectTypes.ts` to understand why type coercion is used here\n    );\n\n    //store 2nd cleanup\n    this.cleanups.push(ComponentCleanup);\n    //store reference to function used to update component return function dependencies and return template\n    //result for rendering\n    this.ComponentDependencyUpdate = ComponentDependencyUpdate;\n\n    this.Component = () => {\n      //check \"changed\" flag to prevent multiple redundant re-rendering of components.\n      if (this.changed) {\n        this.changed = false;\n        queueRevertChangedToTrue(this);\n        const [htmlTemplateResult] = this.ComponentDependencyUpdate?.();\n\n        return htmlTemplateResult;\n      } else {\n        return noChange;\n      }\n    };\n    //prevent re-initialization of component on subsequent renders after initialization.\n    this.updateFlag = \"externalRender\";\n\n    return htmlTemplateResult;\n  }\n\n  update(\n    part: ChildPart,\n    [Component, props]: [\n      (props: any, parent: Node) => () => TemplateResult,\n      any\n    ]\n  ) {\n    //initialize component for the first time or go through normal rendering processes based on the state of `updateFlag`\n    return this[this.updateFlag](props, part, Component);\n  }\n\n  protected reconnected(): void {\n    this.updateFlag = \"initialize\";\n  }\n\n  render() {\n    return this.Component();\n  }\n}\n\ndeclare function hFn(\n  Component: () => () => TemplateResult,\n  props?: null\n): DirectiveResult;\n\ndeclare function hFn<Type>(\n  Component: Component<Type>,\n  props: Type\n): DirectiveResult;\n\nconst h: typeof hFn = directive($);\n\nexport default h;\n","import { AsyncDirective } from \"lit-html/async-directive\";\n\ntype hAsyncDirective = AsyncDirective & { changed: boolean };\n\nconst changedArray1: hAsyncDirective[] = [];\nconst changedArray2: hAsyncDirective[] = [];\nlet one = true;\n\nexport default function queueRevertChangedToTrue(\n  componentAsyncDirective: hAsyncDirective\n) {\n  const changedArray = one ? changedArray1 : changedArray2;\n  const newOne = one ? false : true;\n\n  changedArray.push(componentAsyncDirective);\n\n  if (changedArray.length === 1) {\n    queueMicrotask(() => {\n      one = newOne;\n      changedArray.forEach(\n        (componentAsyncDirective) => (componentAsyncDirective.changed = true)\n      );\n      changedArray.length = 0;\n    });\n  }\n}\n","import createEffect from \"./createEffect\";\nimport {\n  EffectFn,\n  EffectOptions,\n  ComponentFnExecuteFn,\n  DepArray,\n} from \"./effectTypes\";\n\nexport default function adaptComponentFnEffect<\n  T = any,\n  U extends any[] = any[]\n>(fn: EffectFn<T, U>, depArray: DepArray<U>, options?: EffectOptions) {\n  const [execute, effect] = createEffect(\"sync\", \"componentFn\", fn, depArray);\n\n  //return cleanup function / component cleanup array\n  return execute(\n    effect,\n    fn,\n    depArray,\n    options\n  ) as ReturnType<ComponentFnExecuteFn>;\n}\n","import executeFns from \"./executeFns\";\nimport sendSignal from \"./sendSignal\";\nimport setInitialParameters from \"../setInitialParameters\";\nimport setCleanupSet from \"../setCleanupSet\";\nimport {\n  ComponentFnExecuteFn,\n  DepArray,\n  InternalEffectObject,\n  EffectFn,\n  ExecuteFn,\n} from \"./effectTypes\";\n\nexport default function createEffect<T = any, U extends any[] = any[]>(\n  type: \"async\" | \"sync\" | \"render\",\n  tracking: \"implicit\" | \"depArray\" | \"componentFn\",\n  fn: EffectFn<T, U>,\n  depArray?: DepArray<U>\n) {\n  const execute = executeFns[tracking];\n\n  const effect: InternalEffectObject<T, U> = {\n    //whether or not the effect hasn't been ran before\n    firstRun: true,\n    //whether the effect is async, sync or a render effect\n    type,\n    //how the effect is tracked (refer to the `tracking` variable above)\n    tracking,\n    //how many children the effect has\n    childCount: 0,\n    //the number \"n\" that shows that the effect is the \"nth\" child of its parent effect\n    position: null,\n    //how deeply nested the effect is (starting from level one)\n    level: null,\n    //tree-like map data structure that contains the cleanups for every effect in the effect tree\n    cleanupTree: null,\n    //array of digits that point to the effect's cleanup in the effect tree's cleanup tree\n    cleanupTreeNodePointer: null,\n    //subscription sets (async, sync, render, or memo) of every state currently tracking this effect\n    observableSubscriptionSets: new Set(),\n    //used to track the number of state values of states currently tracking the effect that are stale\n    staleStateValuesCount: 0,\n    //used to notify the effect when a state value of state currently tracking the effect turns\n    //stale or freshens up after turning stale\n    sendSignal: (signal: \"fresh\" | \"stale\"): void =>\n      sendSignal(\n        effect,\n        execute as ExecuteFn | ComponentFnExecuteFn,\n        fn,\n        signal,\n        depArray\n      ),\n  };\n\n  //create `cleanupTreeNodePointer` for effect and create `cleanupTree` for effect tree is this is the\n  //topmost parent effect (father of the whole tree)\n  setInitialParameters(effect);\n  //create `cleanupSet` for effect if it doesn't already exist\n  setCleanupSet(effect);\n\n  //return effect `execute` function and effect itself\n  return [execute, effect] as const;\n}\n","import implicitDependencyExecuteFn from \"./implicitDependencyExecuteFn\";\nimport { dependencyArrayExecuteFn } from \"./dependencyArrayExecuteFn\";\nimport { componentFnExecuteFn } from \"./componentFnExecuteFn\";\n\nconst executeFns = {\n  implicit: implicitDependencyExecuteFn,\n  depArray: dependencyArrayExecuteFn,\n  componentFn: componentFnExecuteFn,\n};\n\nexport default executeFns;\n","import { baseExecuteFn } from \"./baseExecuteFn\";\nimport effectAndDescendantCleanup from \"./effectAndDescendantCeanup\";\nimport { InternalEffectObject, EffectFn } from \"./effectTypes\";\n\nexport default function implicitDependencyExecuteFn<\n  T = any,\n  U extends any[] = any[]\n>(effect: InternalEffectObject<T, U>, fn: EffectFn<T, U>) {\n  baseExecuteFn(effect, (cleanupSet) => internalFn(effect, fn, cleanupSet));\n\n  //return cleanup function for effect and its descendants\n  return () => effectAndDescendantCleanup(effect);\n}\n\nfunction internalFn<T = any, U extends any[] = any[]>(\n  effect: InternalEffectObject<T, U>,\n  fn: EffectFn<T, U>,\n  cleanupSet: Set<() => void> | undefined\n) {\n  //call effect with previous return value\n  const fnReturnValue = fn(effect.returnValue);\n  //create `returnValueCleanup` to be called on next run of effect\n  const returnValueCleanup = () => {\n    if (typeof fnReturnValue === \"function\") {\n      //extract new `returnValue` from effect's returned function\n      effect.returnValue = fnReturnValue() as T | undefined;\n    }\n  };\n\n  cleanupSet?.add(returnValueCleanup);\n}\n","import { effectContexts } from \"../effectContexts\";\nimport getCleanupNode from \"../getCleanupNode\";\nimport observableSubscriptionsCleanup from \"../observableSubscriptionsCleanup\";\nimport { InternalEffectObject } from \"./effectTypes\";\n\nexport function baseExecuteFn(\n  effect: InternalEffectObject,\n  fn: (cleanupSet: Set<() => void> | undefined) => void\n) {\n  //set `childCount` back to zero to enable children effects to obtain correct positions upon recreation\n  effect.childCount = 0;\n\n  //fire cleanups make sure proceedings go smoothly\n  const cleanupSet = getCleanupNode(effect)?.get(0) as\n    | Set<() => void>\n    | undefined;\n  cleanupSet?.forEach((cleanup) => {\n    cleanup();\n  });\n  cleanupSet?.clear();\n\n  //push effect onto context to enable tracking by state and memos\n  effectContexts.push(effect);\n\n  fn(cleanupSet);\n\n  //add cleanup to remove effect from all old subscriptions\n  cleanupSet?.add(() => observableSubscriptionsCleanup(effect));\n\n  //remove effect from context to disable tracking by state and memos\n  effectContexts.pop();\n}\n","import { InternalEffectObject } from \"./adaptEffect/effectTypes\";\n\n//stack to track effects that are currently being tracked by state and memos\nexport const effectContexts: InternalEffectObject[] = [];\n","import { CleanupTree, InternalEffectObject } from \"./adaptEffect/effectTypes\";\n\n//use `cleanupTreeNodePointer` of effect to get `cleanupNode` of effect\n//this is basically the cleanup tree for the effect tree that begins with this effect\nexport default function getCleanupNode(effect: InternalEffectObject) {\n  let cleanupNode = effect.cleanupTree;\n\n  effect.cleanupTreeNodePointer?.forEach((part) => {\n    cleanupNode = cleanupNode?.get(part) as CleanupTree;\n  });\n\n  return cleanupNode;\n}\n","import { InternalEffectObject } from \"./adaptEffect/effectTypes\";\n\nexport default function observableSubscriptionsCleanup(\n  effect: InternalEffectObject\n) {\n  effect.observableSubscriptionSets.forEach((observableSubscriptionSet) => {\n    observableSubscriptionSet.delete(effect);\n  });\n  effect.observableSubscriptionSets.clear();\n}\n","import getCleanupNode from \"../getCleanupNode\";\nimport { CleanupTree, InternalEffectObject } from \"./effectTypes\";\n\nfunction traverseAndEvaluate(cleanupNode: CleanupTree | null) {\n  let nextChildNode = 0;\n  while (cleanupNode?.get(nextChildNode)) {\n    if (nextChildNode === 0) {\n      const cleanupSet = cleanupNode.get(0) as Set<() => void>;\n      cleanupSet.forEach((cleanup) => {\n        cleanup();\n      });\n      cleanupSet.clear();\n    } else {\n      const nextCleanupNode = cleanupNode.get(nextChildNode) as CleanupTree;\n      traverseAndEvaluate(nextCleanupNode);\n    }\n\n    nextChildNode++;\n  }\n}\n\nexport default function effectAndDescendantCleanup(\n  effect: InternalEffectObject\n) {\n  const cleanupNode = getCleanupNode(effect);\n  traverseAndEvaluate(cleanupNode);\n}\n","import { baseExecuteFn } from \"./baseExecuteFn\";\nimport effectAndDescendantCleanup from \"./effectAndDescendantCeanup\";\nimport {\n  DepArray,\n  InternalEffectObject,\n  EffectFn,\n  EffectOptions,\n} from \"./effectTypes\";\n\nexport function dependencyArrayExecuteFn<T = any, U extends any[] = any[]>(\n  effect: InternalEffectObject<T, U>,\n  fn: EffectFn<T, U>,\n  depArray: DepArray<U>,\n  options: EffectOptions = {}\n) {\n  baseExecuteFn(effect, (cleanupSet) =>\n    internalFn(effect, fn, depArray, options, cleanupSet)\n  );\n\n  return () => effectAndDescendantCleanup(effect);\n}\n\nfunction internalFn<T = any, U extends any[] = any[]>(\n  effect: InternalEffectObject<T, U>,\n  fn: EffectFn<T, U>,\n  depArray: DepArray<U>,\n  options: EffectOptions = {},\n  cleanupSet: Set<() => void> | undefined\n) {\n  //if effect is supposed to be deferred, do nothing on the first run\n  if (effect.firstRun && options.defer) {\n    effect.firstRun = false;\n  } else {\n    //call effect with previous return value and previous state values of tracking state and memos in an `argsArray`\n    const fnReturnValue = fn(effect.returnValue, effect.argsArray);\n    //create `returnValueCleanup` to be called on next run of effect\n    const returnValueCleanup = () => {\n      if (typeof fnReturnValue === \"function\") {\n        //extract new `returnValue` from effect's returned function\n        effect.returnValue = fnReturnValue() as T | undefined;\n      }\n    };\n\n    //add cleanup to obtain new return value\n    cleanupSet?.add(returnValueCleanup);\n  }\n\n  //set tracking to \"implicit\" to enable tracking by state and memos in `depArray`\n  effect.tracking = \"implicit\";\n  effect.argsArray = depArray.map((state) => state()) as U;\n  //set tracking back to \"depArray\" to disable other forms of implicit tracking\n  //(only allow state and memos in `depArray` to track effect)\n  effect.tracking = \"depArray\";\n}\n","import { baseExecuteFn } from \"./baseExecuteFn\";\nimport effectAndDescendantCleanup from \"./effectAndDescendantCeanup\";\nimport {\n  DepArray,\n  InternalEffectObject,\n  EffectFn,\n  EffectOptions,\n} from \"./effectTypes\";\nimport updateEffectDependencies from \"./updateEffectDependencies\";\n\nexport function componentFnExecuteFn<T = any, U extends any[] = any[]>(\n  effect: InternalEffectObject<T, U>,\n  fn: EffectFn<T, U>,\n  depArray: DepArray<U>,\n  options: EffectOptions = {}\n) {\n  baseExecuteFn(effect, (cleanupSet) =>\n    internalFn(effect, fn, depArray, options, cleanupSet)\n  );\n\n  return [\n    () => effectAndDescendantCleanup(effect),\n    () => updateEffectDependencies(effect, depArray),\n    effect.argsArray,\n  ] as const;\n}\n\nexport default function internalFn<T = any, U extends any[] = any[]>(\n  effect: InternalEffectObject<T, U>,\n  fn: EffectFn<T, U>,\n  depArray: DepArray<U>,\n  options: EffectOptions = {},\n  cleanupSet: Set<() => void> | undefined\n) {\n  //set tracking to \"implicit\" to enable tracking by state and memos in `depArray`\n  effect.tracking = \"implicit\";\n  effect.argsArray = depArray.map((state) => state()) as U;\n  //set tracking back to \"depArray\" to disable other forms of implicit tracking\n  //(only allow state and memos in `depArray` to track effect)\n  effect.tracking = \"depArray\";\n\n  //if effect is supposed to be deferred, do nothing on the first run\n  if (effect.firstRun && options.defer) {\n    effect.firstRun = false;\n  } else {\n    //call effect with previous return value and previous state values of tracking state and memos in an `argsArray`\n    const fnReturnValue = fn(effect.returnValue, effect.argsArray);\n    //create `returnValueCleanup` to be called on next run of effect\n    const returnValueCleanup = () => {\n      if (typeof fnReturnValue === \"function\") {\n        //extract new `returnValue` from effect's returned function\n        effect.returnValue = fnReturnValue() as T | undefined;\n      }\n    };\n\n    //add cleanup to obtain new return value\n    cleanupSet?.add(returnValueCleanup);\n  }\n}\n","import { Getter } from \"../adaptState/stateTypes\";\nimport { baseExecuteFn } from \"./baseExecuteFn\";\nimport { InternalEffectObject } from \"./effectTypes\";\n\n//created for the purpose of component-wrapping effects\nexport default function updateEffectDependencies<T>(\n  effect: InternalEffectObject,\n  depArray: Getter<T>[]\n) {\n  baseExecuteFn(effect, () => internalFn(effect, depArray));\n\n  return effect.argsArray;\n}\n\nfunction internalFn<T>(effect: InternalEffectObject, depArray: Getter<T>[]) {\n  effect.tracking = \"implicit\";\n  effect.argsArray = depArray.map((state) => state());\n  effect.tracking = \"depArray\";\n}\n","import { Getter } from \"../adaptState/stateTypes\";\nimport addAsyncEffect from \"./addAsyncEffect\";\nimport addRenderEffect from \"./addRenderEffect\";\nimport {\n  ComponentFnExecuteFn,\n  DepArray,\n  InternalEffectObject,\n  EffectFn,\n  ExecuteFn,\n} from \"./effectTypes\";\n\nexport default function sendSignal<T = any, U extends any[] = any[]>(\n  effect: InternalEffectObject,\n  execute: ExecuteFn | ComponentFnExecuteFn,\n  fn: EffectFn<T, U>,\n  signal: \"stale\" | \"fresh\",\n  depArray?: DepArray<U>\n) {\n  if (signal === \"stale\") {\n    effect.staleStateValuesCount++;\n  } else if (signal === \"fresh\") {\n    effect.staleStateValuesCount--;\n    if (effect.staleStateValuesCount <= 0) {\n      //to make sure \"effect.stateStateValuesCount\" doesn't go beyond zero\n      effect.staleStateValuesCount = 0;\n      executeMap[effect.type as \"sync\" | \"render\" | \"async\"](\n        effect,\n        execute,\n        fn,\n        depArray\n      );\n    }\n  }\n}\n\nconst executeMap = {\n  sync: <T = any, U extends any[] = any[]>(\n    effect: InternalEffectObject,\n    execute: ExecuteFn | ComponentFnExecuteFn,\n    fn: EffectFn<T, U>,\n    depArray?: DepArray<U>\n  ) => execute(effect, fn, depArray!),\n  async: <T = any, U extends any[] = any[]>(\n    effect: InternalEffectObject,\n    execute: ExecuteFn | ComponentFnExecuteFn,\n    fn: EffectFn<T, U>,\n    depArray?: DepArray<U>\n  ) => addAsyncEffect(() => execute(effect, fn, depArray!)),\n  render: <T = any, U extends any[] = any[]>(\n    effect: InternalEffectObject,\n    execute: ExecuteFn | ComponentFnExecuteFn,\n    fn: EffectFn<T, U>,\n    depArray?: DepArray<U>\n  ) => addRenderEffect(() => execute(effect, fn, depArray!)),\n};\n","const asyncEffectArray1: any = [];\nconst asyncEffectArray2: any = [];\nlet one = true;\n\nexport default function addAsyncEffect(fn: any) {\n  const asyncEffectArray = one ? asyncEffectArray1 : asyncEffectArray2;\n  const newOne = one ? false : true;\n\n  asyncEffectArray.push(fn);\n\n  if (asyncEffectArray.length === 1) {\n    queueMicrotask(() => {\n      one = newOne;\n      asyncEffectArray.forEach((fn: any) => fn());\n      asyncEffectArray.length = 0;\n    });\n  }\n}\n","const renderEffectArray1: any = [];\nconst renderEffectArray2: any = [];\nlet one = true;\n\nexport default function addRenderEffect(fn: any) {\n  const renderEffectArray = one ? renderEffectArray1 : renderEffectArray2;\n  const newOne = one ? false : true;\n\n  renderEffectArray.push(fn);\n\n  if (renderEffectArray.length === 1) {\n    queueMicrotask(() => {\n      one = newOne;\n      renderEffectArray.forEach((fn: any) => fn());\n      renderEffectArray.length = 0;\n    });\n  }\n}\n","import { InternalEffectObject } from \"./adaptEffect/effectTypes\";\nimport { effectContexts } from \"./effectContexts\";\n\nexport default function setInitialParameters(effect: InternalEffectObject) {\n  const parentEffect = effectContexts[effectContexts.length - 1];\n  if (parentEffect) {\n    //use \"position\" and \"level\" to determine location of effect cleanup\n    //in cleanup tree\n    //increment the parent effect's child count to account for its new child effect\n    parentEffect.childCount++;\n    //the effect's position \"n\" shows that it's the \"nth\" child of its parent effect\n    effect.position = parentEffect.childCount;\n    //the effect's level shows how many levels deep it is nested (one level deeper than its parent effect)\n    effect.level = (parentEffect.level as number) + 1;\n    //all effects in a tree have the same cleanup tree\n    effect.cleanupTree = parentEffect.cleanupTree;\n    //copy parent's `cleanupTreeNodePointer` and continue from there\n    effect.cleanupTreeNodePointer = [\n      ...(parentEffect.cleanupTreeNodePointer as number[]),\n    ];\n\n    //complete `cleanupTreeNodePointer` for the effect\n    //every number's presence in the array represents an extra level of nesting (eg. one number for the first\n    //and topmost level, three numbers for two levels deeper than the topmost level, etc)\n    //the value \"n\" of every number in the array shows that the effect is the \"nth\" effect in that level of nesting\n    let effectCleanupTreeNodePointerLength =\n      effect.cleanupTreeNodePointer.length;\n    if (effectCleanupTreeNodePointerLength === effect.level) {\n      effect.cleanupTreeNodePointer[effectCleanupTreeNodePointerLength - 1] =\n        effect.position;\n    } else if (effectCleanupTreeNodePointerLength < effect.level) {\n      effect.cleanupTreeNodePointer[effectCleanupTreeNodePointerLength] =\n        effect.position;\n    } else if (effectCleanupTreeNodePointerLength > effect.level) {\n      effect.cleanupTreeNodePointer.pop();\n      effect.cleanupTreeNodePointer[effectCleanupTreeNodePointerLength - 2] =\n        effect.position;\n    }\n  } else {\n    //do this for the topmost parent effect (father of the whole tree)\n    effect.level = 1;\n    effect.position = 1;\n    effect.cleanupTreeNodePointer = [1];\n    effect.cleanupTree = new Map();\n  }\n}\n","import { CleanupTree, InternalEffectObject } from \"./adaptEffect/effectTypes\";\n\nexport default function setCleanupSet(effect: InternalEffectObject) {\n  //create variable to store `cleanupNode` of effect and initially set the variable to the cleanup tree\n  let cleanupNode: CleanupTree | null = effect.cleanupTree;\n\n  //extract the `cleanupNode` from the `cleanupTree` and set it to the `cleanupNode` variable\n  effect.cleanupTreeNodePointer?.forEach((part) => {\n    if (cleanupNode?.get(part)) {\n      cleanupNode.set(part, new Map());\n    }\n    cleanupNode = cleanupNode?.get(part) as CleanupTree;\n  });\n\n  //set cleanup set for effect if it doesn't already exist in the cleanup map\n  if (cleanupNode?.get(0)) {\n    cleanupNode.set(0, new Set());\n  }\n}\n","import createEffect from \"./createEffect\";\nimport { EffectFn, EffectOptions, ExecuteFn, DepArray } from \"./effectTypes\";\n\nexport default function adaptSyncEffect<T = any, U extends any[] = any[]>(\n  fn: EffectFn<T, U>,\n  depArray?: DepArray<U>,\n  options?: EffectOptions\n) {\n  //determine if the effect is tracked by the state it uses implicitly, or using the\n  //state provided by its dependency array\n  const tracking = typeof depArray === \"undefined\" ? \"implicit\" : \"depArray\";\n\n  const [execute, effect] = createEffect(\"sync\", tracking, fn, depArray);\n\n  //return cleanup function / component cleanup array\n  return execute(effect, fn, depArray!, options) as ReturnType<ExecuteFn>;\n}\n","import get from \"../get\";\nimport set from \"./set\";\nimport { InternalStateObject, State } from \"./stateTypes\";\n\nexport function adaptState<T>(): State<T | undefined>;\nexport function adaptState<T>(initialValue: T | (() => T)): State<T>;\nexport function adaptState<T>(initialValue?: T | (() => T)): State<T> {\n  //create state object with three sets of subscriptions\n  const state: InternalStateObject<T> = {\n    //one for sync effect subscriptions\n    //use two sets to effectively manage synchronous subscriptions (prevents recursive filling\n    //and running of effects resulting in stack overflow)\n    syncSubscriptions: {\n      one: new Set(),\n      two: new Set(),\n    },\n    //one for memo subscriptions\n    //use two sets to effectively manage synchronous subscriptions (prevents recursive filling\n    //and running of memos resulting in stack overflow)\n    memoSubscriptions: {\n      one: new Set(),\n      two: new Set(),\n    },\n    //one for async and render effect subscriptions\n    //one set is enough to manage asynchronous effects\n    asyncAndRenderSubscriptions: new Set(),\n    //use variable to effectively switch between subscription sets (for sync effects and memos)\n    activeSubscriptions: \"one\",\n    value:\n      typeof initialValue === \"function\"\n        ? (initialValue as () => T)()\n        : initialValue,\n  };\n\n  const getter = () => get(state);\n  const setter = (nextValue: T | ((prev: T) => T)) => set(state, nextValue);\n\n  return [getter, setter] as State<T>;\n}\n","import { effectContexts } from \"./effectContexts\";\nimport { InternalStateObject } from \"./adaptState/stateTypes\";\nimport { InternalEffectObject } from \"./adaptEffect/effectTypes\";\n\nfunction subscribe<T = any>(\n  state: InternalStateObject<T>,\n  effect: InternalEffectObject\n) {\n  //get active subscriptions to properly manage sync effects and memos\n  const activeSubscriptions = state.activeSubscriptions;\n  const type = effect.type;\n\n  //if `effect.tracking` is equal to \"depArray\", don't track effects because the tracking\n  //will be done explicitly using the provided dependency array\n  if (effect.tracking === \"depArray\") return;\n\n  //track effects using the right subscription sets, based on whether they are async, render,\n  //sync effects, or memos\n  if (type === \"async\" || type === \"render\") {\n    //tracking async and render effects\n    state.asyncAndRenderSubscriptions.add(effect);\n    effect.observableSubscriptionSets.add(state.asyncAndRenderSubscriptions);\n  } else {\n    //tracking sync effects and memos\n    state[`${type}Subscriptions`][activeSubscriptions].add(effect);\n    effect.observableSubscriptionSets.add(\n      state[`${type}Subscriptions`][activeSubscriptions]\n    );\n  }\n}\n\nexport default function get<T = any>(state: InternalStateObject<T>) {\n  const currentEffect = effectContexts[effectContexts.length - 1];\n  if (currentEffect) {\n    subscribe(state, currentEffect);\n  }\n\n  return state.value;\n}\n","import { updateMemoCleanups } from \"../cleanupUpdateFns\";\nimport { sendStaleSignals, sendFreshSignals } from \"../sendSignals\";\nimport { InternalStateObject } from \"./stateTypes\";\n\nexport default function set<T>(\n  state: InternalStateObject<T>,\n  nextValue: T | ((prev: T) => T)\n) {\n  //get active subscriptions to properly manange sync effects and memos\n  const activeSubscriptions = state.activeSubscriptions;\n  //toggle active subscriptions\n  state.activeSubscriptions = activeSubscriptions === \"one\" ? \"two\" : \"one\";\n\n  //let subscriptions know that they have a stale value so that they can notify their\n  //subscriptions if any\n  sendStaleSignals(state, activeSubscriptions);\n\n  //update state value\n  state.value =\n    typeof nextValue === \"function\"\n      ? (nextValue as (prev: T) => T)(state.value!)\n      : nextValue;\n\n  //let subscriptions know that their stale value has been updated so that they can notify and\n  //update themselves and their subscriptions if any\n  sendFreshSignals(state, activeSubscriptions);\n\n  //update memo cleanups after all effects have been fired to ensure that no memos are run twice, triggering their effects\n  updateMemoCleanups();\n}\n","const cleanupUpdateArray: (() => void)[] = [];\n\nexport function queueCleanupUpdates(cleanupUpdateFn: () => void) {\n  cleanupUpdateArray.push(cleanupUpdateFn);\n}\n\nexport function updateMemoCleanups() {\n  cleanupUpdateArray.forEach((cleanupUpdateFn) => cleanupUpdateFn());\n  cleanupUpdateArray.length = 0;\n}\n","import { InternalStateObject } from \"./adaptState/stateTypes\";\n\nfunction sendStaleSignals(\n  state: InternalStateObject,\n  activeSubscriptions: \"one\" | \"two\"\n) {\n  state.memoSubscriptions[activeSubscriptions].forEach((subscription) => {\n    subscription.sendSignal(\"stale\");\n  });\n\n  state.syncSubscriptions[activeSubscriptions].forEach((subscription) => {\n    subscription.sendSignal(\"stale\");\n  });\n\n  state.asyncAndRenderSubscriptions.forEach((subscription) => {\n    subscription.sendSignal(\"stale\");\n  });\n}\n\nfunction sendFreshSignals(\n  state: InternalStateObject,\n  activeSubscriptions: \"one\" | \"two\"\n) {\n  state.memoSubscriptions[activeSubscriptions].forEach((subscription) => {\n    subscription.sendSignal(\"fresh\");\n  });\n\n  state.syncSubscriptions[activeSubscriptions].forEach((subscription) => {\n    subscription.sendSignal(\"fresh\");\n  });\n\n  state.asyncAndRenderSubscriptions.forEach((subscription) => {\n    subscription.sendSignal(\"fresh\");\n  });\n}\n\nexport { sendStaleSignals, sendFreshSignals };\n","import { State, UnifiedState } from \"./stateTypes\";\n\nexport default function unify<T>(state: State<T>) {\n  function unifiedState(nextValue?: T | ((prev: T) => T)) {\n    if (nextValue === undefined) {\n      return state[0]();\n    } else {\n      return state[1](nextValue);\n    }\n  }\n  return unifiedState as UnifiedState<T>;\n}\n","import { EffectFn, EffectOptions, ExecuteFn, DepArray } from \"./effectTypes\";\nimport createEffect from \"./createEffect\";\n\nexport default function adaptEffect<T = any, U extends any[] = any[]>(\n  fn: EffectFn<T, U>,\n  depArray?: DepArray<U>,\n  options?: EffectOptions\n) {\n  //determine if the effect is tracked by the state it uses implicitly, or using the\n  //state provided by its dependency array\n  const tracking = typeof depArray === \"undefined\" ? \"implicit\" : \"depArray\";\n\n  const [execute, effect] = createEffect(\"render\", tracking, fn, depArray);\n\n  //execute effect asynchronously after next screen paint and return a promise that\n  //resolves with the cleanup function / component cleanup array\n  return new Promise<() => void>((resolve) =>\n    setTimeout(() => {\n      resolve(execute(effect, fn, depArray!, options) as ReturnType<ExecuteFn>);\n    })\n  );\n}\n","import createEffect from \"./createEffect\";\nimport { EffectFn, EffectOptions, ExecuteFn, DepArray } from \"./effectTypes\";\n\nexport default function adaptRenderEffect<T = any, U extends any[] = any[]>(\n  fn: EffectFn<T, U>,\n  depArray?: DepArray<U>,\n  options?: EffectOptions\n) {\n  //determine if the effect is tracked by the state it uses implicitly, or using the\n  //state provided by its dependency array\n  const tracking = typeof depArray === \"undefined\" ? \"implicit\" : \"depArray\";\n\n  const [execute, effect] = createEffect(\"render\", tracking, fn, depArray);\n\n  //execute effect asynchronously before next screen paint and return a promise that\n  //resolves with the cleanup function / component cleanup array\n  return new Promise<() => void>((resolve) => {\n    queueMicrotask(() =>\n      resolve(execute(effect, fn, depArray!, options) as ReturnType<ExecuteFn>)\n    );\n  });\n}\n","import sendSignal from \"./sendSignal\";\nimport get from \"../get\";\nimport setInitialParameters from \"../setInitialParameters\";\nimport setCleanupSet from \"../setCleanupSet\";\nimport { updateValueAndSendFreshNotifications } from \"./notifyAndUpdate\";\nimport { InternalMemoObject } from \"./memoTypes\";\nimport { Getter } from \"../adaptState/stateTypes\";\n\nexport default function adaptMemo<T = any>(fn: (prev?: T) => T): Getter<T> {\n  const memo: InternalMemoObject = {\n    //state properties\n    syncSubscriptions: {\n      one: new Set(),\n      two: new Set(),\n    },\n    memoSubscriptions: {\n      one: new Set(),\n      two: new Set(),\n    },\n    asyncAndRenderSubscriptions: new Set(),\n    activeSubscriptions: \"one\",\n    value: undefined,\n    //effect properties\n    firstRun: true,\n    type: \"memo\",\n    childCount: 0,\n    position: null,\n    level: null,\n    cleanupTree: null,\n    cleanupTreeNodePointer: null,\n    observableSubscriptionSets: new Set(),\n    staleStateValuesCount: 0,\n    sendSignal: (signal) => sendSignal(memo, fn, signal),\n  };\n\n  setInitialParameters(memo);\n  setCleanupSet(memo);\n\n  const cleanupMemo = updateValueAndSendFreshNotifications(memo, fn);\n\n  return (\n    cleanupMemo ? () => get<T>(cleanupMemo) : () => get<T>(memo)\n  ) as Getter<T>;\n}\n","import { InternalMemoObject } from \"./memoTypes\";\nimport {\n  sendStaleNotifications,\n  updateValueAndSendFreshNotifications,\n} from \"./notifyAndUpdate\";\n\nexport default function sendSignal(\n  memo: InternalMemoObject,\n  fn: (prev?: any) => any,\n  signal: \"stale\" | \"fresh\"\n) {\n  if (signal === \"stale\") {\n    memo.staleStateValuesCount++;\n    if (memo.staleStateValuesCount === 1) {\n      sendStaleNotifications(memo);\n    }\n  } else if (signal === \"fresh\") {\n    memo.staleStateValuesCount--;\n    if (memo.staleStateValuesCount <= 0) {\n      //to make sure \"memo.stateStateValuesCount\" doesn't go beyond zero\n      memo.staleStateValuesCount = 0;\n      updateValueAndSendFreshNotifications(memo, fn);\n    }\n  }\n}\n","import observableSubscriptionsCleanup from \"../observableSubscriptionsCleanup\";\nimport getCleanupNode from \"../getCleanupNode\";\nimport { effectContexts } from \"../effectContexts\";\nimport { queueCleanupUpdates } from \"../cleanupUpdateFns\";\nimport { sendStaleSignals, sendFreshSignals } from \"../sendSignals\";\nimport { InternalMemoObject } from \"./memoTypes\";\n\nexport function sendStaleNotifications(memo: InternalMemoObject) {\n  //get active subscriptions to properly manange sync effects and memos\n  const activeSubscriptions = memo.activeSubscriptions;\n  //toggle active subscriptions\n  memo.activeSubscriptions = activeSubscriptions === \"one\" ? \"two\" : \"one\";\n\n  //let subscriptions know that they have a stale value so that they can notify their\n  //subscriptions if any\n  sendStaleSignals(memo, activeSubscriptions);\n}\n\n//aside from a few caveats, this function basically runs like the execute function of an effect\nexport function updateValueAndSendFreshNotifications(\n  memo: InternalMemoObject,\n  fn: (prev?: any) => any\n) {\n  //set `childCount` back to zero to enable children effects to obtain correct positions upon recreation\n  memo.childCount = 0;\n\n  //fire cleanups make sure proceedings go smoothly\n  const cleanupSet = getCleanupNode(memo)?.get(0) as\n    | Set<InternalMemoObject | (() => void)>\n    | undefined;\n  if (cleanupSet) {\n    for (const cleanup of cleanupSet) {\n      //if cleanup is a memo, return it and exit out of function because this means that if the function continues to run\n      //the memo would potentially run twice and re-trigger all of its dependents\n      if (typeof cleanup !== \"function\") {\n        return cleanup;\n      }\n      cleanup();\n    }\n  }\n  cleanupSet?.clear();\n\n  //push memo onto context to enable tracking by state and other memos\n  effectContexts.push(memo);\n\n  memo.value = fn(memo.value);\n\n  if (memo.firstRun) {\n    memo.firstRun = false;\n    //on first run, add cleanup function to cleanupSet\n    cleanupSet?.add(() => observableSubscriptionsCleanup(memo));\n  } else {\n    //else add memo to cleanupSet so that the check that runs inside the for of loop above is able to effectively do its job\n    //and prevent memos from running twice, especially when nested in effects that also depend on them or in other \"edge\" cases\n    cleanupSet?.add(memo);\n    //then `queueCleanupUpdates` for later for the same reasons mentioned in the comment above\n    queueCleanupUpdates(() => {\n      cleanupSet?.clear();\n      cleanupSet?.add(() => observableSubscriptionsCleanup(memo));\n    });\n  }\n\n  //remove memo from context to disable tracking by state and other memos\n  effectContexts.pop();\n\n  //get `activeSubscriptions` as the opposite for `memo.activeSubscriptions` because it recently toggled in `sendStaleNotifications`\n  const activeSubscriptions =\n    memo.activeSubscriptions === \"one\" ? \"two\" : \"one\";\n\n  //let subscriptions know that their stale value has been updated so that they can notify and\n  //update themselves and their subscriptions if any\n  sendFreshSignals(memo, activeSubscriptions);\n}\n","import ParticleEntity from \"./ParticleEntity\";\nimport DerivativeEntity from \"./DerivativeEntity\";\nimport ActionEntity from \"./ActionEntity\";\nimport type { Deletable } from \"./entityTypes\";\n\nexport { ParticleEntity, DerivativeEntity, ActionEntity, Deletable };\n","import { adaptState, State } from \"../nqtui\";\nimport { Deletable, OptionalLiteralKeys } from \"./entityTypes\";\n\ntype ParticleValues = {\n  [key: string]: any;\n};\n\ntype Particles<PV> = {\n  [ParticleValue in keyof PV]: State<PV[ParticleValue]>;\n};\n\nexport default class ParticleEntity<\n  PV extends ParticleValues = ParticleValues\n> {\n  private particles: Particles<PV>;\n\n  constructor(initialParticleValues: PV) {\n    this.particles = {} as Particles<PV>;\n    this.createParticles(initialParticleValues);\n    this.adaptParticle = this.adaptParticle.bind(this);\n    this.deleteParticles = this.deleteParticles.bind(this);\n    this.getParticleValues = this.getParticleValues.bind(this);\n  }\n\n  adaptParticle<T extends keyof PV>(id: T): State<PV[T]>;\n  adaptParticle<T extends keyof PV>(\n    id: T,\n    initialValue: NonNullable<PV[T]>\n  ): State<NonNullable<PV[T]>>;\n  adaptParticle<T extends keyof PV>(\n    id: T,\n    initialValue?: PV[T]\n  ): State<PV[T]> | State<NonNullable<PV[T]>> {\n    if (this.particles[id] === undefined) {\n      this.createParticles({\n        [id as keyof PV]: initialValue as PV[keyof PV],\n      } as Partial<PV>);\n    }\n\n    return this.particles[id] as State<PV[T]>;\n  }\n\n  private createParticles(particleValues: Partial<PV>) {\n    if (particleValues) {\n      Object.keys(particleValues).forEach((particleValue: keyof PV) => {\n        this.particles[particleValue] = adaptState(\n          particleValues[particleValue]\n        ) as State<PV[keyof PV]>;\n      });\n    }\n  }\n\n  deleteParticles(particleIds: Array<OptionalLiteralKeys<PV> | Deletable>) {\n    particleIds.forEach(\n      (particleId) => delete this.particles[particleId as keyof PV]\n    );\n  }\n\n  getParticleValues() {\n    const particleValues = {} as ParticleValues;\n    Object.keys(this.particles).forEach(\n      (particle) => (particleValues[particle] = this.particles[particle][0]())\n    );\n\n    return particleValues;\n  }\n\n  getParticles() {\n    return this.particles;\n  }\n}\n","import { Deletable, OptionalLiteralKeys } from \"./entityTypes\";\n\ntype Derivatives = {\n  [key: string]: () => any;\n};\n\ntype DerivativeValues<D extends Derivatives> = {\n  [Derivative in keyof D]: ReturnType<D[Derivative]>;\n};\n\ntype CompleteAdaptDerivativeReturnType<\n  D extends Derivatives,\n  T extends keyof D\n> =\n  | D[T]\n  | NonNullable<D[T]>\n  | (() => ReturnType<NonNullable<D[T]>> | undefined);\n\nexport default class DerivativeEntity<D extends Derivatives = Derivatives> {\n  private derivatives: D;\n\n  constructor(initialDerivativeFns: D) {\n    this.derivatives = {} as D;\n    this.createDerivatives(initialDerivativeFns);\n    this.adaptDerivative = this.adaptDerivative.bind(this);\n    this.deleteDerivatives = this.deleteDerivatives.bind(this);\n    this.getDerivativeValues = this.getDerivativeValues.bind(this);\n  }\n\n  private createDerivatives(derivatives: Partial<D>) {\n    if (derivatives) {\n      Object.keys(derivatives).forEach((derivative: keyof D) => {\n        this.derivatives[derivative] = derivatives[derivative] as D[keyof D];\n      });\n    }\n  }\n\n  adaptDerivative<T extends keyof D>(\n    id: T\n  ): undefined extends D[T]\n    ? () => ReturnType<NonNullable<D[T]>> | undefined\n    : D[T];\n  adaptDerivative<T extends keyof D>(\n    id: T,\n    initialDerivativeFn: NonNullable<D[T]>\n  ): NonNullable<D[T]>;\n  adaptDerivative<T extends keyof D>(\n    id: T,\n    initialDerivativeFn?: D[T]\n  ): CompleteAdaptDerivativeReturnType<D, T> {\n    if (this.derivatives[id] === undefined) {\n      const fallBackDerivativeFn = () => undefined;\n      this.createDerivatives({\n        [id as keyof D]: (initialDerivativeFn ||\n          fallBackDerivativeFn) as D[keyof D],\n      } as Partial<D>);\n    }\n\n    return this.derivatives[id] as D[T];\n  }\n\n  deleteDerivatives(derivativeIds: Array<OptionalLiteralKeys<D> | Deletable>) {\n    derivativeIds.forEach(\n      (derivativeId) => delete this.derivatives[derivativeId as keyof D]\n    );\n  }\n\n  getDerivativeValues() {\n    const derivativeValues = {} as DerivativeValues<D>;\n    Object.keys(this.derivatives).forEach(\n      (derivative: keyof DerivativeValues<D>) =>\n        (derivativeValues[derivative] = this.derivatives[derivative]())\n    );\n\n    return derivativeValues;\n  }\n\n  getDerivatives() {\n    return this.derivatives;\n  }\n}\n","type Actions = {\n  [key: string]: (payload: any) => any;\n};\nexport default class ActionEntity<A extends Actions = Actions> {\n  actions: A;\n\n  constructor(actions: A) {\n    this.actions = actions;\n    this.dispatch = this.dispatch.bind(this);\n  }\n\n  dispatch(actionId: keyof A, payload: Parameters<A[keyof A]>[0]) {\n    return this.actions[actionId](payload);\n  }\n}\n","import Router from \"./Router\";\n\nexport { Router };\n","import {\n  Component,\n  TemplateResult,\n  adaptMemo,\n  choose,\n  ifDefined,\n} from \"../nqtui\";\nimport { adaptState, html } from \"../nqtui\";\nimport type {\n  Getter,\n  Setter,\n} from \"../nqtui/adaptations/adaptState/stateTypes\";\n\ntype PathsArray = ReadonlyArray<string>;\n\ntype PathsObject = {\n  [key: string]: string;\n};\n\ntype Paths = PathsArray | PathsObject;\n\nexport default class Router<P extends Paths> {\n  paths: P;\n  currentPath: Getter<string>;\n  setCurrentPath: Setter<string>;\n\n  constructor(paths: P) {\n    [this.currentPath, this.setCurrentPath] = adaptState(\n      window.location.pathname\n    );\n    this.paths = paths;\n    window.addEventListener(\"popstate\", () => this.route());\n    this.route = this.route.bind(this);\n    this.navigate = this.navigate.bind(this);\n  }\n\n  Link: Component<{\n    to: P extends PathsArray ? P[number] : P[keyof P];\n    content?: TemplateResult | string | number;\n    text?: string | number;\n    class?: (isActive: boolean) => string;\n    style?: (isActive: boolean) => string;\n  }> = (props) => {\n    const isActive = adaptMemo(() => this.currentPath() === props.to);\n\n    return () =>\n      html`<a\n        href=${props.to}\n        @click=${(e: Event) => {\n          e.preventDefault();\n          this.navigate(props.to);\n        }}\n        class=${ifDefined(props.class?.(isActive()))}\n        style=${ifDefined(props.style?.(isActive()))}\n        >${props.content || props.text}</a\n      >`;\n  };\n\n  navigate(urlOrDelta: string | number) {\n    if (typeof urlOrDelta === \"string\") {\n      history.pushState(null, \"\", urlOrDelta);\n    } else {\n      history.go(urlOrDelta);\n    }\n\n    this.route();\n  }\n\n  route() {\n    this.setCurrentPath(window.location.pathname);\n  }\n\n  Switch: Component<{\n    routes: Array<\n      [P extends PathsArray ? P[number] : P[keyof P], () => TemplateResult]\n    >;\n    default?: () => TemplateResult;\n  }> = (props) => {\n    return () =>\n      html`${choose(this.currentPath(), props.routes, props.default)}`;\n  };\n\n  setTitle(title: string) {\n    document.title = title;\n  }\n}\n"],"names":[],"version":3,"file":"promethium-js.js.map"}